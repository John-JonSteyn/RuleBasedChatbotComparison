#separator:tab
#html:false
#guid column:1
#notetype column:2
#deck column:3
i==*o1[J|$	Basic	Launch into Computing::Unit 04 - Software Engineering	What is Boolean logic in computing?	Boolean logic in computing is a system of algebra where values are reduced to true/false (1/0), enabling decision-making and control structures through operators such as AND, OR, and NOT.
KsUd<n`b<j	Basic	Launch into Computing::Unit 04 - Software Engineering	What are logic gates?	Logic gates are physical electronic components that implement Boolean logic in digital circuits, such as AND, OR, NAND, NOR, and XOR gates.
x-F_hpaS$M	Basic	Launch into Computing::Unit 04 - Software Engineering	What is set theory used for in computing?	Set theory is used to group, organise, and operate on collections of data, forming the theoretical foundation of databases, artificial intelligence, and data management.
hrCo}NYhn,	Basic	Launch into Computing::Unit 04 - Software Engineering	Give three common set operations applied in databases.	The three common set operations applied in databases are union, intersection, and difference.
BoA+S^$JJ1	Basic	Launch into Computing::Unit 04 - Software Engineering	What is an algorithm?	An algorithm is simply a set of instructions for performing a task, much like a recipe for cooking. According to Chapter 11 of Beginning Software Engineering, software algorithms let computers perform tasks such as sorting, searching, or finding optimal solutions to complex problems.
o83S$ed-5;	Basic	Launch into Computing::Unit 04 - Software Engineering	What is computational thinking?	Computational thinking is a structured problem-solving approach involving decomposition, pattern recognition, abstraction, algorithm design, and logical reasoning.
M5W7Ju<&,z	Basic	Launch into Computing::Unit 04 - Software Engineering	What is complexity analysis?	Complexity analysis studies the efficiency of algorithms in terms of execution time and memory usage, often expressed using Big-O notation.
LgsTK3cusi	Basic	Launch into Computing::Unit 04 - Software Engineering	Name three common sorting algorithms.	Three common sorting algorithms are Bubble Sort, Merge Sort, and Quick Sort.
"z}O4#~j_2C"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is software engineering?	According to Chapter 1 of Fundamentals for Self-Taught Programmers, software engineering is the process of building quality software through a set of activities that ensure it works as intended, encompassing more than just writing code.
uvpl1Z19AV	Basic	Launch into Computing::Unit 04 - Software Engineering	List three key aspects of software engineering.	The three key aspects of software engineering are: a problem-solving approach, a lifecycle process, and collaboration.
c717/x{$*7	Basic	Launch into Computing::Unit 04 - Software Engineering	How does software engineering differ from simple programming?	Software engineering differs from simple programming because it follows structured methodologies and frameworks, requiring collaboration, systematic testing, and scalability for complex systems.
HUNS2UP,+v	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the six phases of the Software Development Life Cycle (SDLC)?	The six phases of the SDLC are: 1. Requirements Analysis, 2. Design, 3. Implementation, 4. Testing, 5. Deployment, and 6. Maintenance and updates.
w1L*?a&0}4	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the purpose of the SDLC?	The purpose of the SDLC is to provide a structured process that ensures efficient, secure, and user-focused software development.
eDPwGWp.*R	Basic	Launch into Computing::Unit 04 - Software Engineering	Describe the Waterfall model.	The Waterfall model is a linear, sequential SDLC approach where each phase must be completed before the next begins; it is best suited for projects with stable and well-understood requirements.
E@p;[<kuFk	Basic	Launch into Computing::Unit 04 - Software Engineering	Describe the Agile methodology.	Agile is an iterative, flexible SDLC methodology that uses short development cycles called sprints, allowing for continuous stakeholder feedback and adaptation.
lgvpV.@W_Q	Basic	Launch into Computing::Unit 04 - Software Engineering	Describe DevOps.	DevOps is an approach integrating development and operations, emphasising automation, continuous deployment, monitoring, and rapid, reliable delivery of software.
wygG)DKouY	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the purpose of software testing?	The purpose of software testing is to ensure that software is defect-free, meets requirements, and performs reliably across environments and conditions.
c?3X6sZ?<.	Basic	Launch into Computing::Unit 04 - Software Engineering	Name five types of software testing.	Five types of software testing are: unit testing, integration testing, system testing, user acceptance testing (UAT), and performance & security testing.
FJl/$?gx,k	Basic	Launch into Computing::Unit 04 - Software Engineering	How does quality assurance differ from testing?	Quality assurance (QA) differs from testing because QA focuses on improving processes, documentation, and compliance across the software lifecycle, ensuring high standards, while testing focuses on finding defects in the product.
hP,pzPx&?b	Basic	Launch into Computing::Unit 04 - Software Engineering	What tools are commonly used for automated testing?	Common tools for automated testing include Selenium, JUnit, and Postman.
"f#>M-fw??>"	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the four types of software maintenance?	The four types of software maintenance are: corrective (bug fixes), adaptive (updates for hardware/OS changes), perfective (performance/UI improvements and new features), and preventive (architecture improvements to reduce future risks).
"vP>o~/#^1t"	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is software maintenance essential?	Software maintenance is essential because it ensures software remains secure, functional, compatible with changing environments, and efficient over time.
O`~>2_GM}*	Basic	Launch into Computing::Unit 04 - Software Engineering	What is sustainable software development?	Sustainable software development involves practices aimed at reducing environmental impact, such as energy-efficient coding, optimised cloud resource usage, and carbon-neutral data centres.
OoW%X`3u*=	Basic	Launch into Computing::Unit 04 - Software Engineering	What ethical issues must software engineers consider in sustainability?	Ethical issues in sustainable software engineering include minimising AI bias, protecting user privacy, and ensuring accessibility for all users.
e_5l~h.g!&	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the main characteristic of the Waterfall methodology?	The main characteristic of the Waterfall methodology is that it is a linear, sequential model where each SDLC phase must be completed before the next begins.
BXdvl{3.$a	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the advantages of the Waterfall model?	The advantages of the Waterfall model are: clear structure, suitability for projects with strict regulations or stable requirements, and ease of management through comprehensive documentation.
DGN3TV`n`U	Basic	Launch into Computing::Unit 04 - Software Engineering	What is computer science?	Computer science is the study of computational problem solving, where computation refers to systems built for making calculations, including hardware, operating systems, programming languages, and mathematical methods.
"P-DmpJ#j2z"	Basic	Launch into Computing::Unit 04 - Software Engineering	What role does programming play in computer science?	Programming is one of the practices within computer science, where writing code is a way of applying computational methods to solve problems.
qEE;79V_f	Basic	Launch into Computing::Unit 04 - Software Engineering	What is data science in the context of computer science?	According to Chapter 1 of Fundamentals for Self-Taught Programmers, data science is the use of scientific methods, such as statistics, to extract knowledge and hidden relationships from data, often by building models that process inputs to produce useful outputs.
LG`Gp!%y9O	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a model in data science?	A model is a system of mathematical computations that takes data as input and produces results as output, usually in the form of an algorithm.
98:V$G(n%	Basic	Launch into Computing::Unit 04 - Software Engineering	How does machine learning relate to data science?	Machine learning is a subset of data science that focuses on creating models that uncover patterns from data to support rational decisions without human intervention.
x5s][,ZABx	Basic	Launch into Computing::Unit 04 - Software Engineering	How is artificial intelligence different from machine learning?	Artificial intelligence applies acquired knowledge, such as data, to make rational decisions, while machine learning focuses on improving models by learning patterns from data.
r&U*YR`DZX	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the six phases of the software engineering process?	According to Chapter 1 of Fundamentals for Self-Taught Programmers, the six phases of the software engineering process are planning, design, implementation, testing, deployment, and maintenance.
k%ywcj$u(N	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is software development considered an engineering discipline?	According to Chapter 1 of Fundamentals for Self-Taught Programmers, software development is considered engineering because it requires structured processes, careful planning, design standards, quality control, and maintenance, similar to traditional engineering disciplines.
"Pw#*6[M*+L"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the planning phase in software engineering?	The planning phase ensures the project stays on task by defining goals, milestones, and requirements, which guide decisions about technology, team structure, and costs.
JsYlA_8QWg	Basic	Launch into Computing::Unit 04 - Software Engineering	Why are requirements important in the planning phase?	Requirements are vital because they dictate team composition, resources, and technologies, and unclear requirements can slow down or misdirect a project.
AuLMjK]1c+	Basic	Launch into Computing::Unit 04 - Software Engineering	What happens during the design phase in software engineering?	The design phase turns requirements into a vision of how the system will work, including high-level design (technologies and platforms) and low-level design (specific implementation details).
b(8$;|9)9r	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the implementation phase in software engineering?	The implementation phase is where software engineers build the software by translating low-level designs into code, iteratively coding and testing to minimise bugs and errors.
L;]6|9ds[e	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the purpose of the testing phase in software engineering?	The testing phase verifies whether the right system was built and whether it was built correctly, using metrics such as test coverage to ensure reliability and performance.
Dj3huUv.u	Basic	Launch into Computing::Unit 04 - Software Engineering	What is software quality assurance (SQA)?	According to Chapter 1 of Fundamentals for Self-Taught Programmers, software quality assurance is a set of activities throughout the engineering process that assess requirements, design, code, and quality processes to confirm reliability and efficiency.
QqcVFYh?mc	Basic	Launch into Computing::Unit 04 - Software Engineering	What is deployment in the software engineering process?	Deployment is the delivery of the finished software to users, ensuring it matches design expectations, functions in its intended environment, and includes training and support materials if necessary.
I{Mpb!hrfl	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is deployment more than just handing over software?	Deployment requires managing user changes, system dependencies, documentation, and training, as well as handling issues discovered after release.
G@5}=~%[W*	Basic	Launch into Computing::Unit 04 - Software Engineering	What is maintenance in software engineering?	Maintenance is the continuous effort to preserve software quality by fixing bugs, adding features, and adapting to new requirements, making it the longest phase of the life cycle.
GH*|(9H)%i	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is maintenance considered a strategy rather than a single step?	Maintenance is considered a strategy because it involves ongoing practices to keep software safe, relevant, and robust, often restarting parts of the engineering process when needed.
hnNVpN98OH	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the overall contribution of software engineers beyond coding?	According to Chapter 1 of Fundamentals for Self-Taught Programmers, software engineers contribute by applying domain knowledge across all phases—planning, design, implementation, testing, deployment, and maintenance—to deliver high-quality software as part of a team effort.
nn1,&G:Rvj	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the minimal viable product (MVP) in software engineering?	The minimal viable product (MVP) is the first version of software that achieves most of its intended goals and is ready for use by end users.
Jd=+.wIHa2	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is software engineering described as a life cycle?	Software engineering is described as a life cycle because teams repeatedly plan, design, implement, test, deploy, and maintain software as features and improvements are added over time until support ends.
y_uqAh9s!I	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the primary aim of the planning phase?	The primary aim of the planning phase is to clarify what is needed, who is needed, and how many people are needed, while turning stakeholder needs into clear, prioritised, and testable requirements.
k!~Y9bpw=c	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is requirements gathering crucial for project success?	Requirements gathering is crucial because it transforms stakeholder needs into unambiguous, prioritised requirements that drive estimates, design choices, staffing, and delivery timelines.
D^v3XL]Y{y	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the difference between high-level and low-level design?	High-level design converts requirements into major functional components and technology choices, while low-level design breaks those components into detailed structures and behaviours that are ready for implementation.
"C;zP+hXJ#="	Basic	Launch into Computing::Unit 04 - Software Engineering	What is an entity relationship (ER) diagram?	An entity relationship (ER) diagram is a visual representation of a database that shows entities (tables), their attributes (fields), and the relationships between entities.
EA/mycxYb_	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the purpose of defining classes during design?	Defining classes during design specifies the software’s core data structures and behaviours through properties and methods, guiding consistent and maintainable implementation.
"LU0z.yA#^F"	Basic	Launch into Computing::Unit 04 - Software Engineering	What happens in the implementation phase?	In the implementation phase, developers translate low-level designs into code, follow team coding standards, document their work, and typically write tests to verify correctness.
Hs~o(^BRl-	Basic	Launch into Computing::Unit 04 - Software Engineering	Why are coding standards important?	Coding standards are important because they improve readability and maintainability, making it easier for other engineers to understand, extend, and fix the code base.
v92V35Dd@c	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is documentation important during implementation?	Documentation is important because it enables other engineers to understand system behaviour and intent, which supports maintenance, onboarding, and future feature development.
J96;$*U[RO	Basic	Launch into Computing::Unit 04 - Software Engineering	What role does testing play during implementation?	Testing during implementation verifies that code meets design expectations, reduces regressions, and catches defects early so fixes are cheaper and safer.
mz~`8;QXVz	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a bug in software engineering?	A bug is a failure or defect that causes software to behave in a way that does not match its intended or specified functionality.
"Jhn8#XWb}!"	Basic	Launch into Computing::Unit 04 - Software Engineering	How common are bugs in code bases?	According to Chapter 2 of Fundamentals for Self-Taught Programmers, large code bases commonly contain defects, with an average on the order of 15 to 50 bugs per 1,000 lines of code.
i%(wyZ3j|H	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the goal of software testing before release?	The goal of software testing before release is to detect most defects, verify that requirements are met, and ensure that high-severity issues are prioritised and resolved.
dF~fjv$y71	Basic	Launch into Computing::Unit 04 - Software Engineering	Who are QA engineers and what do they do?	QA engineers specialise in assessing software quality by designing and executing tests, identifying defects, verifying fixes, and confirming that the product meets requirements and quality standards.
rrpF&d$C.f	Basic	Launch into Computing::Unit 04 - Software Engineering	Why can’t all bugs be removed from software?	Not all bugs can be removed because complex systems have vast state spaces, evolving requirements, and interdependencies that make exhaustive testing infeasible, so teams focus on catching most defects and fixing the serious ones.
pOnR1E1r]T	Basic	Launch into Computing::Unit 04 - Software Engineering	What is deployment in the software engineering life cycle?	Deployment is the process of releasing software for actual use, which includes preparing environments, updating documentation, planning rollout strategies, and monitoring for issues after launch.
dNQiJ|>r%&	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is deployment more than just pressing “launch”?	Deployment is more than pressing “launch” because it requires staged rollouts or phasing, clear user and operator documentation, incident response plans, and rapid bug-fix processes to manage real-world issues.
lxM*3Uh/rd	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the maintenance phase?	The maintenance phase is the ongoing period after release in which teams fix bugs, improve performance, update documentation, and add or refine features to keep the software useful and reliable.
y4(U}x.fu;	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is maintenance vital for software longevity?	Maintenance is vital because it keeps software relevant, secure, and performant as platforms, dependencies, and user needs change over time.
PuV`_m(D-C	Basic	Launch into Computing::Unit 04 - Software Engineering	When does the software engineering life cycle end?	According to Chapter 2 of Fundamentals for Self-Taught Programmers, the software engineering life cycle ends when the software is no longer supported or maintained by its team.
mgQ`QhZi+5	Basic	Launch into Computing::Unit 04 - Software Engineering	Are new features part of maintenance?	Yes. After the initial release, adding new features typically occurs under maintenance and still follows the plan-design-implement-test-deploy cycle for each change.
APkcVFrF9u	Basic	Launch into Computing::Unit 04 - Software Engineering	How do clear requirements affect later phases?	Clear requirements reduce design ambiguity, enable more accurate estimates, simplify implementation decisions, and make testing and acceptance criteria objective and verifiable.
gNeZw=UA(W	Basic	Launch into Computing::Unit 04 - Software Engineering	How does good design accelerate implementation?	Good design accelerates implementation by decomposing the system into well-defined components and interfaces, which reduces rework and coordination overhead during coding.
eSS54U1^h7	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the role of architecture in high-level design?	Architecture in high-level design defines the system’s major components, their responsibilities, and how they interact, guiding technology selection, security boundaries, and data flow.
t>YjjA_lLm	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is traceability from requirements to tests useful?	Traceability is useful because it maps each requirement to design elements, code, and tests, ensuring coverage, supporting audits, and simplifying change impact analysis.
IdLy*]X9(?	Basic	Launch into Computing::Unit 04 - Software Engineering	Why does prioritisation matter during testing?	Prioritisation matters because resources are limited; focusing on high-severity and high-likelihood failures first reduces user risk and improves time to a reliable release.
dOZ)H;=|TX	Basic	Launch into Computing::Unit 04 - Software Engineering	Why should documentation be updated before deployment?	Documentation should be updated before deployment to ensure users and operators know how to use features, configure systems, and report issues, which reduces support load and confusion.
"fl98j:#2>%"	Basic	Launch into Computing::Unit 04 - Software Engineering	What are indicators of a healthy maintenance process?	Indicators include steady reduction of severe bugs, predictable release cadence, clear documentation, responsive incident handling, and continuous improvement of code quality and performance.
ufF:g?VufZ	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the overarching lesson of the life cycle for engineers?	The overarching lesson is that building quality software requires active participation in every phase, not just coding, because planning, design, testing, deployment, and maintenance directly determine long-term success.
KX6|xJ3Z6O	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the overarching purpose of this chapter?	According to Chapter 3 of Fundamentals for Self-Taught Programmers, the chapter introduces common roles on a software team and clarifies each role’s responsibilities and typical specialisations.
bEF+k1%WG<	Basic	Launch into Computing::Unit 04 - Software Engineering	Do the titles engineer, developer, and programmer differ in meaning?	According to Chapter 3 of Fundamentals for Self-Taught Programmers, the titles engineer, developer, and programmer are often used interchangeably in the industry to mean professionals who develop software.
>}BA`e:eq	Basic	Launch into Computing::Unit 04 - Software Engineering	Why do large projects need multiple software roles?	According to Chapter 3 of Fundamentals for Self-Taught Programmers, large projects span planning, design, implementation, testing, deployment, and maintenance, each with distinct needs, so teams rely on specialised roles to solve different classes of problems efficiently.
"BBTRh#E>?#"	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the primary goals of a project manager on a software team?	According to Chapter 3 of Fundamentals for Self-Taught Programmers, a project manager determines why the team is doing the project, identifies who is responsible for its success, and creates a plan for how to deliver it.
N?%!~D[K]$	Basic	Launch into Computing::Unit 04 - Software Engineering	What does a project manager produce from stakeholder conversations?	According to Chapter 3 of Fundamentals for Self-Taught Programmers, a project manager converts stakeholder needs into a written requirements document that defines success criteria and can serve as an agreement or contract.
GX{lP[]/!$	Basic	Launch into Computing::Unit 04 - Software Engineering	How does a project manager connect stakeholders and engineers?	According to Chapter 3 of Fundamentals for Self-Taught Programmers, a project manager acts as the communication bridge, actively listens, asks clarifying questions, and translates stakeholder needs into actionable tasks for engineers.
AiilDTO(5n	Basic	Launch into Computing::Unit 04 - Software Engineering	Why does a project manager need technical literacy?	According to Chapter 3 of Fundamentals for Self-Taught Programmers, a project manager needs enough technical knowledge to converse effectively with engineers, understand challenges at a high level, and explain prototypes and progress to stakeholders.
h_;NQ0/j3F	Basic	Launch into Computing::Unit 04 - Software Engineering	What is change management versus change control in projects?	According to Chapter 3 of Fundamentals for Self-Taught Programmers, change management addresses organisational and staffing changes, while change control governs changes to the project’s requirements and scope.
uJ?cDI+&01	Basic	Launch into Computing::Unit 04 - Software Engineering	How might a project manager respond if requirements exceed the schedule?	According to Chapter 3 of Fundamentals for Self-Taught Programmers, a project manager may propose hiring more engineers or extending the timeline, then apply change control to limit new requirements until after the initial release.
Es{Y]%8*[`	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the core responsibilities of a web developer?	A web developer builds websites or web apps, working with the browser as the primary runtime and focusing on client-side, server-side, or both.
Q5)+Ti^L$P	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the difference between client and server in web development?	The client is where the website is accessed, typically a browser on a user’s device, while the server is the computer that stores and runs the website’s server-side code.
j{jH.(<9yK	Basic	Launch into Computing::Unit 04 - Software Engineering	Which languages do frontend developers primarily use and why?	Frontend developers primarily use HTML for structure and content, CSS for presentation and layout, and JavaScript for interactivity and event handling in the browser.
xwh(T*,DyD	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a full stack web developer?	"A full stack web developer works across both frontend and backend, using HTML, CSS, JavaScript, and one or more server-side languages such as C#, Java, or JavaScript on the server."
q0ytA+:CUC	Basic	Launch into Computing::Unit 04 - Software Engineering	What does a backend software engineer do?	A backend software engineer writes server-side code that handles data operations, exposes functionality through APIs, and optimises performance and resource usage on the server.
O}RJi0rk~h	Basic	Launch into Computing::Unit 04 - Software Engineering	What are CRUD operations?	CRUD operations are the four basic data actions in applications: create, read, update, and delete.
"I/]{#LX(U?"	Basic	Launch into Computing::Unit 04 - Software Engineering	Why are access control and permissions essential for backend updates?	Backend updates must verify user identity and authorisation so that only permitted users can change sensitive records, protecting data integrity and privacy.
hQa%=Ix=x-	Basic	Launch into Computing::Unit 04 - Software Engineering	What is an application programming interface?	An application programming interface, or API, is software that exposes defined operations for other software to use, commonly enabling CRUD operations on data without direct database access.
hfsb.2{oe!	Basic	Launch into Computing::Unit 04 - Software Engineering	Why do teams prefer a single API rather than many direct database accesses?	A single API centralises validation, security, and business rules, reduces duplication, and lowers the risk that multiple engineers accidentally bypass safeguards.
sWwPdpv(M@	Basic	Launch into Computing::Unit 04 - Software Engineering	How do backend engineers approach performance?	Backend engineers measure execution times and resource use, locate bottlenecks with profiling or monitoring tools, and refactor or redesign code paths to run faster or use fewer resources.
t.?5+7YYfT	Basic	Launch into Computing::Unit 04 - Software Engineering	What does a mobile software engineer build?	A mobile software engineer builds applications for mobile devices such as iOS and Android, often handling both user interface behaviours and backend interactions for the app.
jnqJuP[{Ft	Basic	Launch into Computing::Unit 04 - Software Engineering	Which languages are commonly used for native mobile apps?	iOS apps are commonly built with Swift, and Android apps are commonly built with Java or Kotlin. Cross-platform frameworks allow a shared code base to target multiple platforms.
b@mf99fWXI	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the user interface in a mobile app?	The user interface is the collection of visual views and interactive elements that users see and touch, such as screens, buttons, and forms.
k,3A59%BIX	Basic	Launch into Computing::Unit 04 - Software Engineering	How do mobile engineers handle varying screen sizes and orientations?	Mobile engineers use layout systems and tools that adapt view dimensions and positioning so the interface renders correctly on different device sizes and orientations.
xk,g,2YPnC	Basic	Launch into Computing::Unit 04 - Software Engineering	What is accessibility in mobile applications?	Accessibility is designing and implementing app interactions that support diverse user needs, for example voice navigation, readable labels, and assistive descriptions for interactive elements.
JwkYNJS0$,	Basic	Launch into Computing::Unit 04 - Software Engineering	What does a quality assurance software engineer focus on?	A quality assurance engineer focuses on validating that software meets requirements and quality standards by designing and executing tests, finding defects, and confirming fixes.
pF+acy3$Ak	Basic	Launch into Computing::Unit 04 - Software Engineering	What are a test plan and a test case?	A test plan outlines the overall approach and scope for testing a system, while a test case specifies inputs, conditions, and the expected result for a particular behaviour.
A+1z>3,~0E	Basic	Launch into Computing::Unit 04 - Software Engineering	Why automate test cases?	Automating stable, repeatable test cases reduces manual effort, speeds feedback, and allows engineers and QA to focus on higher value exploratory and edge-case testing.
Cl;^egS`?9	Basic	Launch into Computing::Unit 04 - Software Engineering	Why are logs important in automated testing?	Logs record test outcomes and histories, helping teams diagnose false positives or negatives and trace when and where a failure pattern began.
Ak5YOSGx!9	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the role of documentation in QA work?	QA documentation captures test plans, test cases, and observed behaviours over time, creating a history that helps teams understand regressions and locate sources of defects.
PF?@WIcFgl	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a DevOps engineer?	According to Chapter 3 of Fundamentals for Self-Taught Programmers, a DevOps engineer builds and maintains tooling that connects development and operations to automate and improve quality, speed, and reliability across the software life cycle.
yhpsWSY$(p	Basic	Launch into Computing::Unit 04 - Software Engineering	Why do teams use a staging environment?	A staging environment mirrors production so teams can verify that new builds behave correctly in a realistic setup before releasing to users.
iP/8U-]09F	Basic	Launch into Computing::Unit 04 - Software Engineering	How can DevOps reduce delays between code submission and testing?	According to Chapter 3 of Fundamentals for Self-Taught Programmers, DevOps pipelines can automatically build code, deploy to staging, and notify QA, shortening the path from commit to verification.
"co6(1G#9:]"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is DevSecOps?	DevSecOps integrates security practices into DevOps so that vulnerability detection, secure configuration, and compliance checks are automated early and throughout the delivery process.
H.SUMq5oy;	Basic	Launch into Computing::Unit 04 - Software Engineering	Why include security in pipelines and tooling?	Automating security checks catches vulnerabilities in code, dependencies, infrastructure, and credentials early, reducing risk, remediation cost, and the chance of privacy incidents.
IL_MuK<S-`	Basic	Launch into Computing::Unit 04 - Software Engineering	How do roles span the software engineering life cycle?	According to Chapter 3 of Fundamentals for Self-Taught Programmers, roles contribute across phases: PMs steer planning and change, developers implement features, QA validates quality, and DevOps automates build, test, and release, with all roles supporting maintenance.
jQsnmjV-,r	Basic	Launch into Computing::Unit 04 - Software Engineering	What distinguishes frontend, backend, and full stack work in practice?	Frontend focuses on browser-based user experiences, backend focuses on server-side data and logic, and full stack bridges both, implementing features end-to-end.
eW]p}s;JIG	Basic	Launch into Computing::Unit 04 - Software Engineering	How do project managers keep plans adaptable?	According to Chapter 3 of Fundamentals for Self-Taught Programmers, project managers track tasks in a shared system, reassess risks, adjust staffing and priorities, and manage requirement changes to keep delivery on track.
mX}OaA8(iF	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is interpersonal skill vital for project managers?	According to Chapter 3 of Fundamentals for Self-Taught Programmers, PMs coordinate diverse stakeholders and engineers, resolve conflicts, build trust, and maintain morale so collaboration remains effective.
BTBsBhR$q5	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the summary lesson about roles on software teams?	According to Chapter 3 of Fundamentals for Self-Taught Programmers, modern software teams rely on complementary roles whose specialisations collectively enable planning, building, testing, deploying, securing, and maintaining high-quality software.
x.o6p_/W|$	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the basic steps required for successful software engineering?	According to Chapter 1 of Beginning Software Engineering, basic steps include gathering requirements, producing high-level and low-level designs, developing code, testing at multiple levels, deploying to users, maintaining and enhancing the system, and performing a postmortem to capture lessons learned.
D@m|8pA6%~	Basic	Launch into Computing::Unit 04 - Software Engineering	How is software engineering similar to other engineering disciplines?	According to Chapter 1 of Beginning Software Engineering, software engineering shares the need to plan, follow that plan, overcome obstacles, coordinate teams, and deliver a system that meets clearly stated goals, much like building bridges or aircraft.
dePnY6MfGs	Basic	Launch into Computing::Unit 04 - Software Engineering	How is software engineering different from other engineering disciplines?	According to Chapter 1 of Beginning Software Engineering, software’s malleability and lack of physical constraints encourage late scope changes, platform switches, and compressed schedules that would be impossible in physical engineering projects.
DxY$9ryL*$	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is a plan indispensable for large software projects?	According to Chapter 1 of Beginning Software Engineering, a plan sets goals, responsibilities, timing, and scope so that teams know what to build, how long it should take, and how to judge success.
G!EzXpDabf	Basic	Launch into Computing::Unit 04 - Software Engineering	What does requirements gathering accomplish?	According to Chapter 1 of Beginning Software Engineering, requirements gathering identifies what customers need and want, and converts that understanding into approved requirements documents that guide design, development, and acceptance.
kvVBwFI~T=	Basic	Launch into Computing::Unit 04 - Software Engineering	Who counts as the customer in a software project?	The customer can be an internal department, external buyers, a broad market not yet fully known, or even the development team itself if building tools for their own use.
v7ZQ)/{AD@	Basic	Launch into Computing::Unit 04 - Software Engineering	Why should developers interact with customers throughout the project?	Regular interaction clarifies needs, surfaces contradictions between wants and needs, validates priorities, and reduces the risk of building features that do not add value.
u$Iy/Z,]NN	Basic	Launch into Computing::Unit 04 - Software Engineering	What are requirements documents used for?	Requirements documents communicate what will be delivered, serve as a baseline for change control, and let both customers and team members verify whether proposed features align with agreed goals.
e:h4z.d2},	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the role of change control during a project?	According to Chapter 1 of Beginning Software Engineering, change control evaluates late requests against value, risk, and schedule impact, allowing worthwhile changes while protecting delivery dates and scope.
jTL)T8rwAM	Basic	Launch into Computing::Unit 04 - Software Engineering	Why do software projects experience more last minute changes than physical projects?	Because software is easy to modify and not constrained by physical fabrication, stakeholders often assume changes are cheap and fast, prompting requests close to release.
B9|^-1`h&@	Basic	Launch into Computing::Unit 04 - Software Engineering	What is high-level design?	High-level design makes platform choices, defines major architectural components, identifies data and system interfaces, and allocates responsibilities among large subsystems without prescribing low-level implementation details.
B<@Q|bux;n	Basic	Launch into Computing::Unit 04 - Software Engineering	What should a high-level design cover?	It should cover every requirement, explain what each major part does, and specify how parts interact, while intentionally avoiding unnecessary implementation detail.
yFbt<D~$3_	Basic	Launch into Computing::Unit 04 - Software Engineering	What is low-level design?	Low-level design explains how each component will work, detailing data structures, algorithms, interfaces, and constraints sufficiently to guide implementation.
QSPDV}HuNY	Basic	Launch into Computing::Unit 04 - Software Engineering	Why do designs evolve across components?	As teams refine one area, they discover cross component interactions and constraints that necessitate adjustments elsewhere, improving cohesion and feasibility.
xj2veUP*MK	Basic	Launch into Computing::Unit 04 - Software Engineering	What happens during development?	During development, programmers refine designs into code, iteratively implement features, and test continuously to find and remove as many defects as is practical.
H)!IN&W{96	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is it hard to test your own code effectively?	Developers implicitly assume their own logic is correct, tend to avoid adversarial test thinking, and may miss integration behaviours that only emerge when components interact.
F.%Z$sC<(c	Basic	Launch into Computing::Unit 04 - Software Engineering	What kinds of testing reduce blind spots?	According to Chapter 1 of Beginning Software Engineering, multi level testing helps: developers test their own code, independent testers validate behaviour, and integrated system tests check interactions and regressions.
q-w~OB:G9w	Basic	Launch into Computing::Unit 04 - Software Engineering	Why must code be retested after a fix?	Fixing one defect can introduce another, change a dependency other code relied on, or alter correct behaviour in unexpected ways, so regression testing is necessary after any change.
rNqFZE+bg7	Basic	Launch into Computing::Unit 04 - Software Engineering	What principle about testing did Dijkstra articulate?	Testing can show the presence of bugs, not their absence, so absence of failures in tests is not proof that a system is bug free.
j:x$nN0Kpj	Basic	Launch into Computing::Unit 04 - Software Engineering	What does the counting bugs example illustrate?	According to Chapter 1 of Beginning Software Engineering, an early mistake can propagate multiplicatively across phases, turning one requirements error into many design and development mistakes, greatly increasing the repair effort later.
G8LE7Z3H;P	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is detecting mistakes early so important?	According to Chapter 1 of Beginning Software Engineering, the longer a bug remains undetected, the harder and costlier it becomes to fix, because downstream decisions and code depend on the faulty premise.
rmMp6Tr+VI	Basic	Launch into Computing::Unit 04 - Software Engineering	What are some realities of deployment for large systems?	Deployment may require new servers and networks, user devices, training, on site support, parallel runs with legacy systems, data synchronization, and rapid bug fixing as real users expose issues not found in testing.
O+[AUQJEyK	Basic	Launch into Computing::Unit 04 - Software Engineering	Why should projects include contingency in deployment plans?	Real world usage reveals unpredictable edge cases, integration quirks, and human factors that cannot be fully anticipated, so schedules should reserve time and capacity for the unexpected.
J23@-P=`&d	Basic	Launch into Computing::Unit 04 - Software Engineering	What is maintenance in the software lifecycle?	Maintenance is the ongoing work after release to fix newly discovered bugs, respond to user feedback, improve performance and usability, and add enhancements that keep the system valuable.
"ELd#LE-,*N"	Basic	Launch into Computing::Unit 04 - Software Engineering	Why do users find bugs that testers missed?	Users exercise the system at scale and in diverse, messy scenarios, uncovering edge cases and usage patterns that controlled tests did not cover.
F1Cx;HjMwM	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a postmortem and why do one?	A postmortem is a retrospective that captures what went well and what went poorly, so teams can institutionalise good practices and avoid repeating mistakes while details are still fresh.
PU>{sELIVY	Basic	Launch into Computing::Unit 04 - Software Engineering	Why do core tasks often overlap in large projects?	To use team time efficiently, requirements, design, development, and testing proceed in parallel, with coordination to manage the higher risk of rework from earlier stage changes.
z:[zX[G7Vk	Basic	Launch into Computing::Unit 04 - Software Engineering	Can work ever flow backward in the lifecycle?	Yes. Problems discovered in development or testing can reveal flaws in earlier designs or requirements, forcing upstream corrections with broader impact.
kV3~g3{/aY	Basic	Launch into Computing::Unit 04 - Software Engineering	Why are early requirement repairs valuable?	Catching missing or incorrect requirements during development prevents larger cascades of errors and rework, saving time even if it requires immediate design and code adjustments.
P2o$t-<)(%	Basic	Launch into Computing::Unit 04 - Software Engineering	How do different development models relate to the same core tasks?	All models still perform requirements, design, development, testing, deployment, and maintenance; they differ mainly in timing, formality, iteration frequency, and how much change they allow mid stream.
c53aJC_J-s	Basic	Launch into Computing::Unit 04 - Software Engineering	How do agile and test driven approaches reduce late surprise?	They encourage frequent builds and early, continuous testing, which surfaces defects and mismatches sooner, shrinking the cost and impact of fixes.
n]|YhB}kf,	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a practical way to keep design lean but present?	Even in iterative methods, maintain enough high level and low level design to guide implementation and integration, avoiding over specification while preventing architectural drift.
o$4aE8!Zn]	Basic	Launch into Computing::Unit 04 - Software Engineering	What are some basic steps to problem solving in software projects?	Some basic steps to problem solving are define the problem clearly with stakeholders, propose alternatives, choose a design approach, implement incrementally with tests, validate with independent testing, deploy safely, and capture lessons in a postmortem to improve next time.
cR5uk-u-Xy	Basic	Launch into Computing::Unit 04 - Software Engineering	How can teams manage late feature requests without derailing schedules?	Apply change control: estimate value and impact, defer non essential items, batch changes into future releases, and communicate trade offs transparently with stakeholders.
Gkdz^2_Yjm	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a good rule of thumb for design detail?	Specify what components do and how they interact at a high level, and provide enough low level detail for developers to implement correctly, but avoid premature micro detail that will likely change during coding and testing.
q$!{>EWv<B	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is iterative refinement a useful development technique?	Gradually adding detail until writing code is the simplest next step preserves clarity, exposes gaps early, and reduces wasted effort on speculative detail.
f`@8|9%mQ}	Basic	Launch into Computing::Unit 04 - Software Engineering	What mindset helps testers add value beyond executing scripts?	An adversarial, exploratory mindset that challenges assumptions, probes edge cases, and questions completeness of requirements and designs helps reveal issues early across all stages.
dgN%msvZhO	Basic	Launch into Computing::Unit 04 - Software Engineering	Why should you set up document control before starting the project?	According to Chapter 2 of Beginning Software Engineering, early document control lets you archive ideas, track evolving requirements and decisions, and avoid rehashing old choices, so the team can execute against the latest agreed facts.
G:&=A<ti9b	Basic	Launch into Computing::Unit 04 - Software Engineering	Why do software projects need a formal change control approach?	According to Chapter 2 of Beginning Software Engineering, without change control, evolving requirements become muddled and conflicting; a change control board or single arbiter evaluates requests, balances value vs. schedule risk, and stabilizes scope so delivery is possible.
zlp<UFgff,	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a change control board?	According to Chapter 2 of Beginning Software Engineering, a change control board is a group representing customers and the development team that reviews and approves or rejects change requests to prevent uncontrolled scope churn.
fbraS?gmND	Basic	Launch into Computing::Unit 04 - Software Engineering	Why keep a history of requirements decisions?	According to Chapter 2 of Beginning Software Engineering, a decision history explains why a requirement exists, who requested it, and when; this context enables safe revisions later and prevents wasteful debates and guessing.
LWE(4Pzp3f	Basic	Launch into Computing::Unit 04 - Software Engineering	How can conflicting simultaneous edits to the same document be prevented?	According to Chapter 2 of Beginning Software Engineering, use a document management system that allows shared access but locks a document for editing to a single person at a time, preventing overwrite “race conditions.”
H`_FK~[vCx	Basic	Launch into Computing::Unit 04 - Software Engineering	What core capabilities should a document management system provide?	According to Chapter 2 of Beginning Software Engineering, core capabilities include shared viewing/editing, single-editor locking, retrieval of the latest and prior versions (by date or number), full-text and tag search, version diffing with author and timestamp (ideally “why” notes), and internet/mobile access.
wrUh;x8_xD	Basic	Launch into Computing::Unit 04 - Software Engineering	What optional but useful document management features are mentioned?	According to Chapter 2 of Beginning Software Engineering, useful extras include real-time coauthoring, integrations (Office/Google/PM tools), branching, role-based access, email change notifications, and workflow/routing.
J/Z>uQIA~/	Basic	Launch into Computing::Unit 04 - Software Engineering	Why save “everything” related to the project into the repository?	According to Chapter 2 of Beginning Software Engineering, saving every memo, email, meeting note, and change request creates a searchable source of truth that aligns the team, resolves disputes quickly, and preserves institutional memory.
dzTcwjMJ7_	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the recommended strategy for archiving project emails?	According to Chapter 2 of Beginning Software Engineering, create a dedicated project mailbox and CC it on all project communications; optionally export emails to text files for advanced searches.
tJ9M7S81&v	Basic	Launch into Computing::Unit 04 - Software Engineering	How can email subject tagging improve findability?	According to Chapter 2 of Beginning Software Engineering, prefix subjects with a project tag (e.g., “[CLASP]”) and optional category (e.g., “[CLASP.Test]”) or task identifiers (e.g., “[CLASP.LLDesign.1001]”) so messages are searchable and routable.
xyE;xqvpSA	Basic	Launch into Computing::Unit 04 - Software Engineering	What email categories can help organize communications?	According to Chapter 2 of Beginning Software Engineering, useful tags include Admin, Rqts, HLDesign, LLDesign, Dvt, Test, Deploy, Doc, Train, Maint, and Wrap, as long as the team uses them consistently.
o*8Nph67eA	Basic	Launch into Computing::Unit 04 - Software Engineering	How can routing rules and keywords help with email overload?	According to Chapter 2 of Beginning Software Engineering, client-side rules can file tagged messages automatically; body keywords like “Key: Test” enable searches and filters even when subjects vary.
"NiRy%#Kh-:"	Basic	Launch into Computing::Unit 04 - Software Engineering	Why should email distribution groups be used judiciously?	According to Chapter 2 of Beginning Software Engineering, targeted groups (e.g., managers, customers, testers) ease distribution, but too many lists or accidental cross-posts confuse stakeholders and can damage trust.
M=*LxmGpa`	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is source code management different from general document management?	According to Chapter 2 of Beginning Software Engineering, code changes frequently and is line-oriented; SCM tools optimize for diffs, checkouts, and merges at line granularity, whereas document systems better track prose edits, so separate tools fit each domain.
M]~Z@:n.mi	Basic	Launch into Computing::Unit 04 - Software Engineering	What basic workflows should source control support?	According to Chapter 2 of Beginning Software Engineering, SCM should let developers check out modules for exclusive edits (or safe merges), ensure others can use but not overwrite in-progress changes, and integrate with IDEs to reduce errors.
G>eq$IS.Hs	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is code written “for people” rather than computers?	Code must be understood, debugged, and maintained by humans; the computer executes compiled/translated binaries, so human readability, not just performance, determines long-term safety and adaptability.
u*1mUT^]g_	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the practical goal of code documentation and comments?	According to Chapter 2 of Beginning Software Engineering, documentation and comments create a breadcrumb trail explaining intent, design choices, and tricky behaviors so current and future developers (possibly you) can modify code safely.
m}xjMf,Q}s	Basic	Launch into Computing::Unit 04 - Software Engineering	What should be documented in code vs. outside code?	According to Chapter 2 of Beginning Software Engineering, maintain high- and low-level design docs in the repository for architectural understanding, and write inline code comments to explain non-obvious logic, interfaces, and gotchas; skip trivial line-by-line narration.
ssz(`13$~t	Basic	Launch into Computing::Unit 04 - Software Engineering	What is “JBGE” and how can it go wrong?	According to Chapter 2 of Beginning Software Engineering, “just barely good enough” documentation aims to minimize maintenance overhead, but teams often over-apply it, producing too little documentation to understand or safely change the system.
qZB/E$ZswU	Basic	Launch into Computing::Unit 04 - Software Engineering	What evidence is given about the risks of under-documenting?	According to Chapter 2 of Beginning Software Engineering, real projects with sparse comments forced days of code reading for tiny changes and introduced new bugs; another team removed “excess” comments and later restored them after losing maintainability.
rYPJ9p$l.C	Basic	Launch into Computing::Unit 04 - Software Engineering	When should you add comments relative to coding?	According to Chapter 2 of Beginning Software Engineering, finish writing and testing a coherent chunk of code, then document it; you need not update comments after every line change, but write while the context is still fresh.
jp_{pZM?J	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is JBGE especially dangerous for requirements documentation?	According to Chapter 2 of Beginning Software Engineering, vague or ambiguous requirements push developers to work at cross-purposes, spawning conflict and rework; clarity avoids civil-war-level disagreements and aligns execution.
DMq>ufSTUV	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the chapter’s guidance on applying JBGE across the lifecycle?	According to Chapter 2 of Beginning Software Engineering, while avoiding bloat is sensible, making everything “just barely good enough” (requirements, design, code, tests) yields results that are not good enough overall.
m_N>[cbU*K	Basic	Launch into Computing::Unit 04 - Software Engineering	What are XML documentation comments and why use them?	"According to Chapter 2 of Beginning Software Engineering, languages like C# support structured comments (e.g., <summary>, <param>) that can be extracted into API docs and surfaced as IDE tooltips, clarifying interfaces for other developers."
i{k</vUaH@	Basic	Launch into Computing::Unit 04 - Software Engineering	How should application-facing documentation be planned?	According to Chapter 2 of Beginning Software Engineering, plan and produce user manuals, quick starts, cheat sheets, UI maps, training and marketing materials (and variants like video/screencasts) early enough that users can adopt the system at release.
H9yLL;3@]0	Basic	Launch into Computing::Unit 04 - Software Engineering	What risk arises if you delay training and user docs?	According to Chapter 2 of Beginning Software Engineering, late or changing UIs can make timely training materials impossible, blocking adoption and frustrating trainers and end users.
lIm2k:CnH/	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is it useful to capture meeting and call summaries?	According to Chapter 2 of Beginning Software Engineering, summarized notes (emailed to participants and archived) resolve disagreements quickly, document decisions and action items, and add to the searchable project history.
"Npsh#ro7L9"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the “Font Fiasco” lesson?	According to Chapter 2 of Beginning Software Engineering, knowing the original rationale (e.g., 16-point Arial for slide readability vs. Comic Sans ban) determines whether and how a requirement can be safely changed (e.g., to 14-point Arial).
Kw`$/M`XjW	Basic	Launch into Computing::Unit 04 - Software Engineering	How do document version comparisons help daily work?	According to Chapter 2 of Beginning Software Engineering, diffing two versions shows exactly what changed, who changed it, and when—accelerating impact analysis and enabling rollback when a change proves harmful.
KY5Uo1&M4R	Basic	Launch into Computing::Unit 04 - Software Engineering	What problem does single-writer locking avoid?	According to Chapter 2 of Beginning Software Engineering, it prevents a race where two edits to the same document overwrite each other, losing the first change when the second is saved.
st!wD$ify~	Basic	Launch into Computing::Unit 04 - Software Engineering	How do tags and searchability shape effective archives?	According to Chapter 2 of Beginning Software Engineering, consistent tags, subject prefixes, and keyword conventions make it trivial to retrieve related artifacts (e.g., all testing emails) and keep stakeholders oriented.
d8SdK`^.5$	Basic	Launch into Computing::Unit 04 - Software Engineering	Why separate project communications for different audiences?	According to Chapter 2 of Beginning Software Engineering, customers shouldn’t receive internal technical debates or blunt assessments; audience-appropriate channels prevent confusion and maintain professional relationships.
vf_7u$2@PV	Basic	Launch into Computing::Unit 04 - Software Engineering	What mindset should guide all documentation work?	The mindset should be to keep the whole team aligned on the same goals with clear, searchable, up-to-date artifacts that explain what to do, why it was decided, and how to proceed when changes arise.
s>7r=IxMN.	Basic	Launch into Computing::Unit 04 - Software Engineering	How do these practices help across the entire lifecycle?	According to Chapter 2 of Beginning Software Engineering, solid document/email/code practices support requirements clarity, design traceability, coordinated development, efficient testing, smoother deployment, and maintainable evolution after release.
O?k`s7Z/yp	Basic	Launch into Computing::Unit 04 - Software Engineering	What are some basic steps to problem solving in documentation chaos?	Some basic steps to problem solving are establish a single source of truth (repository + conventions), tag and archive all artifacts, institute change control, enforce single-writer or merge-safe edits, and routinely summarize decisions so future work proceeds from facts rather than memories.
wi5KnCwEXT	Basic	Launch into Computing::Unit 04 - Software Engineering	What are some common features of effective teams?	According to Chapter 3 of Beginning Software Engineering, common features of effective teams include clear roles, effective leadership, clear goals, consensus, open communication, support for risk-taking, shared accountability, an informal atmosphere, and trust among members.
u/UytReuf9	Basic	Launch into Computing::Unit 04 - Software Engineering	Why are clear roles important in a software team?	According to Chapter 3 of Beginning Software Engineering, clear roles are important because they define who makes which decisions and handles specific tasks, preventing wasted time, confusion, and conflict when choices must be made.
oZpzQS&&iz	Basic	Launch into Computing::Unit 04 - Software Engineering	What makes leadership “effective” in software teams?	According to Chapter 3 of Beginning Software Engineering, effective leadership focuses on enabling the team to succeed rather than controlling every decision, by guiding direction, supporting resources, arbitrating when necessary, and maintaining trust without micromanaging.
OCT.>UcozY	Basic	Launch into Computing::Unit 04 - Software Engineering	How do clear goals affect a team’s performance?	According to Chapter 3 of Beginning Software Engineering, clear goals keep a team aligned, reduce wasted effort on unnecessary debates, and prevent confusion or conflict, while unclear goals can lead to delays, disagreements, or even hostility.
eu2w4l?@t?	Basic	Launch into Computing::Unit 04 - Software Engineering	What role does consensus play in team decision-making?	According to Chapter 3 of Beginning Software Engineering, consensus reduces the sense of winners and losers in decisions, making members more likely to work together productively in the future, although tie-breaking leadership may still be needed at times.
s:nB~(aNKU	Basic	Launch into Computing::Unit 04 - Software Engineering	What does open communication mean in a team context?	According to Chapter 3 of Beginning Software Engineering, open communication means team members can share concerns, bad news, or failures safely without punishment, and that communication is secured against loss or theft depending on the project’s sensitivity.
pF.:XE8$_r	Basic	Launch into Computing::Unit 04 - Software Engineering	Why should teams support risk-taking?	According to Chapter 3 of Beginning Software Engineering, teams should support risk-taking because innovation and progress require experimentation, and punishing failed attempts discourages creativity and can prevent improvements.
g9oB23~t/d	Basic	Launch into Computing::Unit 04 - Software Engineering	What is shared accountability in a team?	According to Chapter 3 of Beginning Software Engineering, shared accountability means the team takes collective responsibility for problems rather than blaming individuals, fostering collaboration, reducing fear, and encouraging better problem solving.
BHY]k~$6rt	Basic	Launch into Computing::Unit 04 - Software Engineering	How does an informal atmosphere benefit a software team?	According to Chapter 3 of Beginning Software Engineering, an informal atmosphere promotes openness, easier consensus, and willingness to ask for help, all of which support healthier collaboration and better results.
k_smyG$h4/	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is trust essential in software teams?	According to Chapter 3 of Beginning Software Engineering, trust is essential because without it, team members cannot communicate openly, share accountability, reach consensus, or rely on leadership, which undermines the entire team structure.
OZ-3B^|t_j	Basic	Launch into Computing::Unit 04 - Software Engineering	What are common formal roles in software teams?	According to Chapter 3 of Beginning Software Engineering, common formal roles include project manager/tracker, technical lead, team leader, developer, customer or client, analyst or domain expert, system administrator, and database administrator.
c_[C/m);L5	Basic	Launch into Computing::Unit 04 - Software Engineering	What are some specialized roles that larger projects may require?	According to Chapter 3 of Beginning Software Engineering, specialized roles in larger projects may include database designer, change manager, software architect, tester, user interface designer, technical writer, trainer, and other subject matter experts depending on project needs.
zFr1!@q!rw	Basic	Launch into Computing::Unit 04 - Software Engineering	What are examples of informal roles in software teams?	According to Chapter 3 of Beginning Software Engineering, informal roles may include language lawyer, toolsmith, facilitator, coach or mentor, and scribe, which are usually taken up by people with other formal responsibilities.
Gz;A~?}Avu	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the role of team culture in effectiveness?	According to Chapter 3 of Beginning Software Engineering, team culture shapes whether members collaborate effectively, feel comfortable working together, and build trust, with positive cultures boosting productivity and toxic cultures leading to dysfunction.
Olq}v^fTk[	Basic	Launch into Computing::Unit 04 - Software Engineering	What activities can help build team culture?	According to Chapter 3 of Beginning Software Engineering, activities such as lunches, parties, trips, conferences, and community service can strengthen bonds and improve team culture if they encourage voluntary participation.
B=xMd5{XVr	Basic	Launch into Computing::Unit 04 - Software Engineering	What are features of toxic team cultures?	According to Chapter 3 of Beginning Software Engineering, toxic cultures are marked by harassment, discrimination, favoritism, cliques, gossip, weak leadership, ignored feedback, inconsistent rules, poor work-life balance, high turnover, and bullying.
r@eq|ue1`P	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the most important question to answer in interviews?	According to Chapter 3 of Beginning Software Engineering, the most important interview question is whether the candidate and the team would enjoy working together, since compatibility outweighs raw brilliance in determining long-term success.
ka?}RU]Lit	Basic	Launch into Computing::Unit 04 - Software Engineering	Why are interview puzzles discouraged?	According to Chapter 3 of Beginning Software Engineering, interview puzzles are discouraged because they mainly test whether candidates have seen a puzzle before, not whether they can program effectively, and they don’t predict real ability.
px_4mm|DVB	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the role of the physical environment in software development?	According to Chapter 3 of Beginning Software Engineering, the physical environment affects creativity, comfort, and focus, with the best settings balancing collaboration and distraction with privacy and concentration.
kE3RfpeNSt	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the flow state in creative work?	The flow state, also called the zone, is a period of deep focus where everything seems to fall into place, allowing extended productivity and creativity, though it risks tunnel vision if overextended.
YvpUWvozC	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is balance between focus and distraction important?	According to Chapter 3 of Beginning Software Engineering, balance between focus and distraction prevents tunnel vision and allows subconscious problem solving, helping developers maintain both creativity and accuracy.
h5{v~^J?Oj	Basic	Launch into Computing::Unit 04 - Software Engineering	What are ergonomic considerations for software developers?	According to Chapter 3 of Beginning Software Engineering, ergonomic considerations include proper posture with adjustable chairs and desks, correct monitor and keyboard placement, good lighting, frequent breaks, and early attention to symptoms of strain or injury.
Fq=Hu7$N)-	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is work-life balance important in software teams?	According to Chapter 3 of Beginning Software Engineering, work-life balance prevents burnout, supports retention, and ensures long-term productivity, whereas extreme work-focused cultures risk losing their best people and damaging morale.
rY}`2_(w]7	Basic	Launch into Computing::Unit 04 - Software Engineering	What are collaboration tools, and what risks do they pose?	According to Chapter 3 of Beginning Software Engineering, collaboration tools support remote work and communication but can create issues if meetings are unsearchable without transcripts or if teams are overloaded with too many platforms.
BVSir_U{9i	Basic	Launch into Computing::Unit 04 - Software Engineering	What problems can outsourcing introduce?	According to Chapter 3 of Beginning Software Engineering, outsourcing can complicate culture, communication, and project control due to time zones, language, security, and training delays, but it can work if goals are clear and not time-critical.
riT,5cHbJA	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is management necessary in software projects?	According to Chapter 4 of Beginning Software Engineering, management is necessary to set goals, track progress, and ensure they are met, while keeping team members focused on solving the problem rather than being distracted by unrelated issues.
m6~NYRN{LJ	Basic	Launch into Computing::Unit 04 - Software Engineering	What is executive support in project management?	According to Chapter 4 of Beginning Software Engineering, executive support is the backing of a high-level executive sponsor or champion who provides resources, shields the project from politics and distractions, and gives the project credibility and authority to succeed.
I=&uMNT9M:	Basic	Launch into Computing::Unit 04 - Software Engineering	What resources can executive champions provide?	According to Chapter 4 of Beginning Software Engineering, executive champions can provide budgets, personnel, hardware, software, office space, administrative guidance, and protection against political attempts to cancel or redirect the project.
eq[Q9I-D6s	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is overworking developers a poor solution to tight deadlines?	According to Chapter 4 of Beginning Software Engineering, overworking developers leads to burnout, sloppy code, and more bugs, which ultimately delays schedules, increases costs, and lowers quality instead of saving time.
HAD%X6H5[-	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the role of the project manager?	According to Chapter 4 of Beginning Software Engineering, the project manager oversees the project through all stages, tracks tasks, manages risks, communicates with customers and stakeholders, manages resources, and ensures delivery of the final product.
B)+p,H5?b~	Basic	Launch into Computing::Unit 04 - Software Engineering	Does a project manager need to be a programming expert?	According to Chapter 4 of Beginning Software Engineering, a project manager does not need to be a programming expert, but having technical and domain knowledge is very helpful for communicating between developers and customers.
MZ]L~0DC.6	Basic	Launch into Computing::Unit 04 - Software Engineering	Why do some projects divide management duties between multiple people?	According to Chapter 4 of Beginning Software Engineering, large projects may divide duties so one manager focuses on scheduling and tracking while another handles technical direction, making the workload more manageable and effective.
sEBia_u:L[	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a PERT chart?	A PERT chart, short for Program Evaluation and Review Technique, is a diagram that shows the relationships and dependencies among project tasks using nodes for tasks and arrows for precedence, helping to plan and visualize the order of execution.
xk.4zO7>PO	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the two main types of PERT charts?	According to Chapter 4 of Beginning Software Engineering, the two main types of PERT charts are activity-on-arrow (AOA), where arrows represent tasks, and activity-on-node (AON), where nodes represent tasks. Activity-on-node is usually easier to build and interpret.
n24X%83f]u	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a critical path in project management?	According to Chapter 4 of Beginning Software Engineering, a critical path is the longest possible sequence of tasks in a project, and any delay in its tasks directly delays the overall project completion.
rBH)S^^1-z	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is the critical path important?	According to Chapter 4 of Beginning Software Engineering, the critical path is important because it identifies the tasks that cannot be delayed without delaying the entire project, guiding managers to focus attention on the most time-sensitive activities.
B_;HSed5`v	Basic	Launch into Computing::Unit 04 - Software Engineering	What flexibility does identifying non-critical tasks give a project manager?	According to Chapter 4 of Beginning Software Engineering, identifying non-critical tasks shows where slack time exists, meaning those tasks can be delayed or rescheduled without impacting the overall project completion date.
Kkn]u|C*}H	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a Gantt chart?	A Gantt chart is a bar chart that shows project tasks as horizontal bars positioned on a calendar, making it easy to see task durations, start and end dates, dependencies, and slack time.
pQ:?|j/.Zo	Basic	Launch into Computing::Unit 04 - Software Engineering	What advantages does a Gantt chart have over a PERT chart?	According to Chapter 4 of Beginning Software Engineering, a Gantt chart shows actual calendar alignment, including weekends and holidays, and makes it easier to see task durations, start/end times, and slack, while PERT charts show dependencies but not exact dates.
fF<0eh7bV-	Basic	Launch into Computing::Unit 04 - Software Engineering	What is project scheduling software used for?	According to Chapter 4 of Beginning Software Engineering, project scheduling software helps automate the creation of PERT and Gantt charts, allows for easy adjustments, defines relationships between tasks, and provides tools to manage complex or large schedules efficiently.
yTAD{pubaq	Basic	Launch into Computing::Unit 04 - Software Engineering	Why are accurate time estimates critical in project management?	According to Chapter 4 of Beginning Software Engineering, accurate time estimates are critical because scheduling tools depend on them, and inaccurate estimates can turn charts into useless plans based on “garbage in, garbage out.”
lCceN,eJAS	Basic	Launch into Computing::Unit 04 - Software Engineering	What strategies improve time estimation?	According to Chapter 4 of Beginning Software Engineering, strategies include using experienced team members, breaking large tasks into smaller pieces, looking for similarities with past work, and planning for predictable lost time such as vacations or delays.
snSa(D]ZN:	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the role of experience in time estimation?	According to Chapter 4 of Beginning Software Engineering, experience improves time estimates because team members who have done similar work can provide realistic expectations and guidance, making their input a best practice for project planning.
k)>UAf/;uA	Basic	Launch into Computing::Unit 04 - Software Engineering	Why should large tasks be broken into smaller pieces?	According to Chapter 4 of Beginning Software Engineering, breaking large tasks into smaller pieces makes them easier to understand, estimate, and plan, and it reduces uncertainty by allowing more accurate predictions for each component.
oB,MAsm.ND	Basic	Launch into Computing::Unit 04 - Software Engineering	What is slack time in project management?	Slack time is the amount of time a task can be delayed without delaying its successor tasks or the overall project completion.
mHT8bP.bJq	Basic	Launch into Computing::Unit 04 - Software Engineering	Why should managers expect the unexpected in time estimation?	According to Chapter 4 of Beginning Software Engineering, managers should expect the unexpected because delays such as illness, vacations, approvals, or supply chain issues are inevitable, so buffers and contingency plans are needed.
"nCo=#Cg(,h"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the risk of adding general buffer time to every task?	According to Chapter 4 of Beginning Software Engineering, adding buffer time to every task can backfire because people tend to use all available time, effectively extending the project unnecessarily without reserving slack for real issues.
OBLhNpo]^&	Basic	Launch into Computing::Unit 04 - Software Engineering	What is risk management in project management?	According to Chapter 4 of Beginning Software Engineering, risk management is the proactive process of identifying possible risks, assessing their likelihood and severity, studying consequences, and planning workarounds before problems occur.
lodg;G<k3q	Basic	Launch into Computing::Unit 04 - Software Engineering	What factors are considered in risk analysis?	According to Chapter 4 of Beginning Software Engineering, risk analysis considers likelihood of problems, severity if the task fails, consequences for other tasks, and the difficulty, impact, pros, and cons of potential workarounds.
qw<l,=AnNL	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is tracking progress important in projects?	According to Chapter 4 of Beginning Software Engineering, tracking progress ensures that slipping tasks are identified early, allowing managers to adjust schedules, allocate resources, or apply risk management strategies instead of being blindsided by delays.
e*6.6Y+e`$	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the danger of ignoring slipping tasks?	According to Chapter 4 of Beginning Software Engineering, ignoring slipping tasks leads to compounded delays, wasted effort, and ultimately project failure, since problems rarely fix themselves without intervention.
omGEAS~N)n	Basic	Launch into Computing::Unit 04 - Software Engineering	Why does adding more people to a late task often make it later?	According to Chapter 4 of Beginning Software Engineering, adding more people to a late task often makes it later because new team members require onboarding, which slows progress, a principle famously stated as “adding manpower to a late software project makes it later.”
P]ey]~S?y(	Basic	Launch into Computing::Unit 04 - Software Engineering	Why are requirements important in software engineering?	Requirements are important because they set the direction for the project, provide guidance during development, and act as criteria for verifying the final product. Without clear requirements, the application may not solve the users' problems.
A*.,5ML@Ns	Basic	Launch into Computing::Unit 04 - Software Engineering	What are software requirements?	According to Chapter 5 of Beginning Software Engineering, software requirements are the features and functions an application must provide. They define what the application should do and serve as a contract between customers and developers.
RcCi-+DFc>	Basic	Launch into Computing::Unit 04 - Software Engineering	What are some characteristics of good requirements?	Some characteristics of good requirements are that they should be clear, unambiguous, consistent, prioritized, and verifiable.
bh&S9kVIb/	Basic	Launch into Computing::Unit 04 - Software Engineering	Why must requirements be clear?	Requirements must be clear so they are easy to understand, specific, and actionable, avoiding vague statements like “improve scheduling” that can be misinterpreted in multiple ways.
wi!;i+8$;N	Basic	Launch into Computing::Unit 04 - Software Engineering	Why must requirements be unambiguous?	Requirements must be unambiguous so there is only one possible interpretation, preventing confusion about how a feature should work or what result it should produce.
d_?zE<KL}j	Basic	Launch into Computing::Unit 04 - Software Engineering	Why must requirements be consistent?	Requirements must be consistent so they do not contradict each other or demand outcomes that cannot be achieved simultaneously, ensuring feasibility.
r*k|t$;*vQ	Basic	Launch into Computing::Unit 04 - Software Engineering	Why must requirements be prioritized?	Requirements must be prioritized so essential features can be delivered first, while less critical ones can be deferred or removed if time and resources are limited.
AL3?!>;nK|	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the MOSCOW method?	According to Chapter 5 of Beginning Software Engineering, the MOSCOW method is a way of prioritizing requirements into four categories: Must, Should, Could, and Won’t.
fj>[4{BtRt	Basic	Launch into Computing::Unit 04 - Software Engineering	What are “Must” requirements in the MOSCOW method?	“Must” requirements are essential features that must be implemented for the project to succeed. Without them, the product is considered incomplete or unusable.
o_,c%piZM$	Basic	Launch into Computing::Unit 04 - Software Engineering	What are “Should” requirements in the MOSCOW method?	“Should” requirements are important features that significantly enhance the product but can be deferred if necessary without rendering the product unusable.
"fu>#|2D=`g"	Basic	Launch into Computing::Unit 04 - Software Engineering	What are “Could” requirements in the MOSCOW method?	“Could” requirements are desirable features that add value but are not critical. They can be implemented if time and budget allow.
n~}v6]9zA*	Basic	Launch into Computing::Unit 04 - Software Engineering	What are “Won’t” requirements in the MOSCOW method?	“Won’t” requirements are optional or low-priority features that the team agrees will not be included in the current release but may be considered in the future.
Aqc_E5Ri$(	Basic	Launch into Computing::Unit 04 - Software Engineering	Why must requirements be verifiable?	Requirements must be verifiable so that developers and customers can confirm whether they have been met, typically by testing or measuring performance against a defined standard.
xE.T/cdoMK	Basic	Launch into Computing::Unit 04 - Software Engineering	What types of words should be avoided in requirements?	Words to avoid include comparatives like “better” or “faster,” vague adjectives like “user-friendly” or “robust,” and unclear commands like “optimize” or “minimize” because they make requirements imprecise.
cz(N6Ogx{]	Basic	Launch into Computing::Unit 04 - Software Engineering	What are business requirements?	Business requirements describe the high-level goals the customer hopes to achieve, such as improving efficiency or profitability, though these are sometimes more aspirational than directly achievable by software alone.
qkGN|BACX)	Basic	Launch into Computing::Unit 04 - Software Engineering	What are user requirements?	User requirements describe how end users will interact with the system. They may include forms, steps for tasks, use cases, or prototypes to illustrate intended use.
G~[d?U!&z%	Basic	Launch into Computing::Unit 04 - Software Engineering	What are functional requirements?	Functional requirements describe what the application should do, including features, workflows, reports, and system interactions.
m$_ydU|ev-	Basic	Launch into Computing::Unit 04 - Software Engineering	What are nonfunctional requirements?	Nonfunctional requirements describe quality attributes and constraints such as performance, reliability, security, and usability.
vw;kpWRMX*	Basic	Launch into Computing::Unit 04 - Software Engineering	What are implementation requirements?	Implementation requirements are temporary features or tasks needed to transition from old systems to new ones, such as data migration or user training.
i[(1r3=YTf	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the FURPS model?	According to Chapter 5 of Beginning Software Engineering, the FURPS model categorizes requirements into Functionality, Usability, Reliability, Performance, and Supportability.
g9,(Z_0P`]	Basic	Launch into Computing::Unit 04 - Software Engineering	What is FURPS+?	FURPS+ is an extension of the FURPS model that adds categories including Design constraints, Implementation requirements, Interface requirements, and Physical requirements.
oY7c<+;DF/	Basic	Launch into Computing::Unit 04 - Software Engineering	Why are requirement categories useful?	Requirement categories act as a checklist to ensure nothing important is overlooked and help balance attention across functionality, usability, performance, reliability, and other critical aspects.
BFk<Q^tKO~	Basic	Launch into Computing::Unit 04 - Software Engineering	What are common requirements found in many applications?	Common requirements include screens and forms, menus, navigation methods, workflows, login and authentication rules, user types with different privileges, audit trails, archiving, and configuration options.
z=QP5(~1IY	Basic	Launch into Computing::Unit 04 - Software Engineering	What techniques help gather requirements?	Techniques for gathering requirements include listening to customers, interviewing users, observing workflows, using the five Ws and one H, brainstorming, copying existing systems, and leveraging prior experience.
e%tFrfXnaA	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the five Ws and one H in requirements gathering?	The five Ws and one H are who, what, when, where, why, and how. They guide conversations to uncover user needs, goals, context, motivations, and possible solutions.
E*Ff5P<L46	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is studying users important in requirements gathering?	Studying users is important because customers and users may overlook critical details or assume knowledge that developers don’t have, so observing actual workflows can reveal hidden needs.
vf}tXtij?L	Basic	Launch into Computing::Unit 04 - Software Engineering	What are some techniques for refining requirements?	According to Chapter 5 of Beginning Software Engineering, techniques include copying features from existing systems, using experienced leads to anticipate needs, and brainstorming to generate innovative solutions.
IU8g$9i}C]	Basic	Launch into Computing::Unit 04 - Software Engineering	What is brainstorming in requirements gathering?	Brainstorming is a creative group activity used to generate many ideas without judgment, later refining them into feasible solutions. It can include methods like sticky notes, idea passing, subgroups, or individual sessions.
BVatW>ME?c	Basic	Launch into Computing::Unit 04 - Software Engineering	What are some tips for effective brainstorming?	Tips include encouraging quantity of ideas, withholding criticism, allowing unusual suggestions, combining and improving ideas, using short lively sessions, and summarizing the best results for further work.
n}f0qMY!T5	Basic	Launch into Computing::Unit 04 - Software Engineering	What are some ways to record requirements?	Ways to record requirements include plain text specifications, UML diagrams, user stories, use cases, and prototypes, each with different levels of formality and detail.
uwQE!sT3^c	Basic	Launch into Computing::Unit 04 - Software Engineering	What are user stories?	User stories are short, simple descriptions of how a user interacts with the system to accomplish a task, often written on index cards, and paired with acceptance criteria for verification.
nj9bax+?$r	Basic	Launch into Computing::Unit 04 - Software Engineering	What are use cases?	Use cases are structured descriptions of interactions between users and systems, including steps for success, variations, and exception handling, often used for larger or more complex tasks than user stories.
AOrr07SCHL	Basic	Launch into Computing::Unit 04 - Software Engineering	What are prototypes in requirements gathering?	Prototypes are mockups or partial implementations of an application that give users a tangible feel for the final product. They can be throwaway prototypes or evolutionary prototypes that grow into the final system.
oZ=EE%hzM^	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the difference between validation and verification of requirements?	Validation ensures the requirements are correct and represent what the customer needs (“Are we building the right thing?”), while verification checks whether the final product meets those requirements (“Did we build it right?”).
j`zC]<uA]K	Basic	Launch into Computing::Unit 04 - Software Engineering	Why do requirements change during a project?	Requirements change because customers refine their understanding, developers discover limitations, or new opportunities arise. Managing changes is necessary to keep projects aligned with goals.
"nFm)wZ^#uO"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is digitization?	Digitization is the process of converting existing manual or analog processes into digital form, such as replacing a paper cash register with a point-of-sale software system.
tCkSnZ)f_;	Basic	Launch into Computing::Unit 04 - Software Engineering	What is digital transformation (DX)?	Digital transformation goes beyond digitization by reimagining and connecting systems to create new capabilities and fundamentally transform a business process or model.
L%^|aVnMuR	Basic	Launch into Computing::Unit 04 - Software Engineering	What cultural challenges can arise in digital transformation?	Cultural challenges include resistance to change, fear of reduced productivity during learning, and job displacement. Involving stakeholders and communicating benefits helps reduce resistance.
oBE,r1N~,;	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the purpose of a high-level design?	A high-level design provides an abstract blueprint that shows the system’s major pieces, the environment they run in, and how those pieces interact so teams can build details later during low-level design and implementation.
u%5.quRq_r	Basic	Launch into Computing::Unit 04 - Software Engineering	How does a high-level design help teams work in parallel?	By decomposing the system into self-contained chunks with clear boundaries, separate teams can implement different pieces concurrently without blocking one another.
qfiK*Rian]	Basic	Launch into Computing::Unit 04 - Software Engineering	When does adding people actually speed development?	Adding people can help only if you split work into largely independent pieces they can own; piling more people onto the same tightly coupled task typically slows things down.
G!Ol-d|01A	Basic	Launch into Computing::Unit 04 - Software Engineering	What belongs in a high-level design at minimum?	At minimum, specify the environment (hardware and software platforms), major subsystems and their responsibilities, how subsystems talk to each other (interfaces), external integrations, data/storage approach, security posture, and high-level user-interface navigation.
pR^nezKV|Q	Basic	Launch into Computing::Unit 04 - Software Engineering	Why include security at the high-level stage?	High-level design is when you decide what you must protect (code, data, credentials) and where risk exists (external attacks, insider errors, lost devices), so you can plan backups, access control, and other safeguards before details harden.
"e{:-Y#_Cp}"	Basic	Launch into Computing::Unit 04 - Software Engineering	What hardware choices does a high-level design capture?	It identifies target devices and infrastructure—e.g., desktops vs. phones vs. IoT, servers (database/web/app), network gear, and any specialized peripherals—so the rest of the design aligns with real-world constraints.
K9!AsFso{U	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the “Pampered Poodle” example meant to illustrate?	According to Chapter 6 of Beginning Software Engineering, it illustrates mapping roles to hardware (drivers on smartphones, office staff on desktops with the database) and choosing connectivity (native apps vs. web) during high-level design.
"e]LCD#?{,O"	Basic	Launch into Computing::Unit 04 - Software Engineering	How detailed should the user interface be in high-level design?	Sketch navigation patterns and major screens or flows (e.g., menu-driven vs. single-window progressive screens), but defer control-level specifics and exact layouts to low-level design.
i}II$4tG+A	Basic	Launch into Computing::Unit 04 - Software Engineering	Why lean on familiar UI conventions?	Familiar patterns reduce training and friction, improve app-store acceptability, and let users focus on the domain task rather than relearning basic interactions.
nG,_niC]~>	Basic	Launch into Computing::Unit 04 - Software Engineering	What are internal interfaces and why define them early?	Internal interfaces specify how your subsystems exchange data/commands; defining them early reduces coupling, enables parallel work, and prevents costly late rework across multiple teams.
fKYJWz3g^D	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a “deferred interface” strategy?	According to Chapter 6 of Beginning Software Engineering, it’s a temporary contract (e.g., shared text files) that lets teams proceed independently until they’re ready to finalize direct calls or APIs.
m)8IMiPsbK	Basic	Launch into Computing::Unit 04 - Software Engineering	How do external interfaces differ from internal ones?	External interfaces are to systems you don’t control; you typically must conform to their existing contracts, while your own system’s published interface should be simple and stable for future consumers.
Q:*0]f0{@:	Basic	Launch into Computing::Unit 04 - Software Engineering	What is software architecture?	Software architecture is the high-level arrangement of system parts and their relationships—patterns like monolithic, client/server, multitier, component-based, service-oriented, event-driven, rule-based, data-centric, and distributed.
la0B@O.$]E	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the pros and cons of a monolithic architecture?	Monoliths are simple to deploy and fast (no network hops), but tightly coupled code makes change risky and coordination harder as the system grows.
uNfR|La^Gj	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a two-tier (client/server) architecture?	A two-tier design separates client functionality (often presentation) from a server (often a database), enabling multiple clients to share data but keeping the client tightly bound to server formats.
tyQRG*m7f*	Basic	Launch into Computing::Unit 04 - Software Engineering	How does a three-tier architecture improve on two-tier?	A middle (logic) tier insulates clients from the data tier, translating formats, aggregating data, and allowing client or data changes without breaking the other side.
m.K>@h<YHp	Basic	Launch into Computing::Unit 04 - Software Engineering	Is N-tier common in practice?	According to Chapter 6 of Beginning Software Engineering, multitier architectures are a best practice for separation of concerns, and few applications use more than three tiers.
jruaSC`f0Q	Basic	Launch into Computing::Unit 04 - Software Engineering	What is component-based software engineering (CBSE)?	CBSE treats the system as loosely coupled components that provide services to each other within the same process, improving modularity without requiring inter-machine networking.
eWOr>M<tr*	Basic	Launch into Computing::Unit 04 - Software Engineering	How is service-oriented architecture (SOA) different from CBSE?	SOA provides services as independently running programs (often web services) that communicate over a network, enabling looser coupling and heterogeneous deployment at the cost of distributed complexity.
n7]aEdDdc6	Basic	Launch into Computing::Unit 04 - Software Engineering	What’s the difference between SOAP and REST in web services?	SOAP is a protocol using structured XML envelopes for cross-platform invocation; REST is an architectural style leveraging standard HTTP verbs and resource URIs, typically exchanging JSON or XML.
s{p9(w}Y`O	Basic	Launch into Computing::Unit 04 - Software Engineering	What are microservices and XaaS in this context?	Microservices are small, independently deployable services you can compose; “X as a Service” (XaaS) exposes infrastructure or platforms (e.g., IaaS, PaaS) or domain capabilities over APIs or control panels that applications consume.
Jic2ZzQxTR	Basic	Launch into Computing::Unit 04 - Software Engineering	What does “data-centric” mean architecturally?	Data-centric designs prioritize data as the organizing force—e.g., relational stores, rule tables driving behavior, or heavy use of stored procedures embedding logic near the data.
cWB1*hx11B	Basic	Launch into Computing::Unit 04 - Software Engineering	What is an event-driven architecture?	An event-driven architecture reacts to business events (order created, item shipped, payment overdue), letting decoupled components subscribe and respond as events occur.
x039D4gK^w	Basic	Launch into Computing::Unit 04 - Software Engineering	When do rule-based systems shine, and when do they fail?	They shine when you can codify decisions as rules (e.g., troubleshooting flows) but struggle with poorly defined domains and unexpected edge cases; always provide a manual override.
QhI8Up;|u^	Basic	Launch into Computing::Unit 04 - Software Engineering	What’s a race condition in distributed systems?	A race condition occurs when two or more concurrent operations interleave in a harmful way—e.g., two purchases read the same balance and overwrite each other—leading to incorrect state unless you add coordination.
LE80q?>ZbI	Basic	Launch into Computing::Unit 04 - Software Engineering	Can you mix architectural styles?	Yes. Real systems often combine styles—for example, an event-driven, three-tier, service-oriented system whose larger services are internally componentized.
h;4Lu_{p;9	Basic	Launch into Computing::Unit 04 - Software Engineering	Why did ClassyDraw choose a monolithic, event-driven design?	According to Chapter 6 of Beginning Software Engineering, ClassyDraw doesn’t need multi-machine tiers or services; its UI is inherently event-driven, so a simple monolith suffices.
M2s]5CSf^<	Basic	Launch into Computing::Unit 04 - Software Engineering	Why plan reporting at a high level?	Reports influence data you must capture, retention needs, and user workflows; identifying key reports early prevents expensive data-model changes later.
"zW_4I#f4LG"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is “ad hoc reporting,” and what guardrails are needed?	Ad hoc reporting lets users write their own queries; you must limit access to sensitive data, prevent destructive commands, and ensure only trusted roles can issue powerful statements.
kH`uU{.iC%	Basic	Launch into Computing::Unit 04 - Software Engineering	What other outputs might a system produce beyond reports?	Systems may generate printouts, files (CSV, images, video), web pages, emails, texts, or signals to external devices (e.g., thermostats, signage) for alerts and automation.
it[Xn*$nZS	Basic	Launch into Computing::Unit 04 - Software Engineering	How should database choices surface in high-level design?	State whether you’ll use files, relational DBs, NoSQL, or hybrids; name candidate products; sketch core tables and relationships if relational; and capture integration and scaling assumptions.
BPM2Xg_+N4	Basic	Launch into Computing::Unit 04 - Software Engineering	Why note key domain classes during high-level design?	Aligning early on classes like Customer, Order, or Shipment ensures the code and database evolve coherently and helps UI and workflow teams speak the same language.
ef`.|L)k]o	Basic	Launch into Computing::Unit 04 - Software Engineering	What is an audit trail and when might you skip it?	An audit trail records who changed what and when; it’s essential for money, safety, or compliance, but you can skip it for playful or internal tools where risk is low.
tn4I=nf4bE	Basic	Launch into Computing::Unit 04 - Software Engineering	How do you handle user access at the data and UI levels?	Define roles/permissions in app logic to hide/disable restricted actions, and leverage database grants and views to restrict table/column access where appropriate.
OAOSqX|%7}	Basic	Launch into Computing::Unit 04 - Software Engineering	What is routine database maintenance you should plan for?	Archiving or warehousing old data, periodic reindexing/tuning, and robust backup/recovery procedures (nightly copies, shadowing, geo-redundancy) keep performance and availability high.
cnl<8_?e:(	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the main NoSQL categories?	Document stores (JSON/XML documents), key-value stores (lookup by key), column-oriented stores (columns stored separately for scale), and graph databases (nodes/edges for relationships).
tQ>.4u^6fC	Basic	Launch into Computing::Unit 04 - Software Engineering	When does a cloud database make sense?	Cloud databases simplify scaling, backups, and reliability; you trade some control for managed operations and elastic capacity that can grow with demand.
KxNtRL.St~	Basic	Launch into Computing::Unit 04 - Software Engineering	Why externalize configuration data?	Externalizing thresholds, toggles, and algorithm parameters lets authorized users adjust behavior (e.g., “late after 35 days”) without code changes or redeploys.
q$gVgh*:o,	Basic	Launch into Computing::Unit 04 - Software Engineering	What are data-flow and state-transition diagrams used for?	Data-flow diagrams show how information moves among processes; state-transition diagrams show how an entity (e.g., an order) changes state in response to events.
cWBDT.1T0l	Basic	Launch into Computing::Unit 04 - Software Engineering	Why plan training during high-level design?	Training needs influence UI choices, support content, and rollout timing; deciding on instructor-led, videos, manuals, or self-service docs early helps downstream teams prepare.
KbXr3m09|E	Basic	Launch into Computing::Unit 04 - Software Engineering	What is UML and when is it useful?	UML is a family of diagram types for modeling structure and behavior; use it selectively when visuals communicate relationships or interactions more clearly than prose.
q/vR82*(*~	Basic	Launch into Computing::Unit 04 - Software Engineering	What does a class diagram convey?	A class diagram shows classes, their attributes and methods, and relationships (associations and inheritance), helping teams agree on the domain model and API surfaces.
wv0czdVHQm	Basic	Launch into Computing::Unit 04 - Software Engineering	"What do visibility markers like +, −, #, and ~ mean in class diagrams?"	"They indicate member visibility: public (+), private (−), protected (#), and package (~), clarifying encapsulation in the design."
x2:c_W!fip	Basic	Launch into Computing::Unit 04 - Software Engineering	How do multiplicities like 1, 0..1, and 1..* help?	They specify how many instances participate in a relationship (exactly one, optional, one or more), preventing mismatched assumptions across teams.
rJ5A&%/*.D	Basic	Launch into Computing::Unit 04 - Software Engineering	What does an activity diagram show?	An activity diagram visualizes workflows with actions, branches, joins, and loops, making parallelism and decision points explicit.
"D<:S7#ot)h"	Basic	Launch into Computing::Unit 04 - Software Engineering	What does a use-case diagram show?	A use-case diagram maps actors (users/systems) to goals (use cases) and can show included steps (<<include>>) and optional extensions (<<extend>>) for scenario structure.
imI;>Dqpn|	Basic	Launch into Computing::Unit 04 - Software Engineering	What does a state-machine diagram show?	A state-machine diagram depicts allowed states of an entity and the events that transition between them, clarifying lifecycle rules and valid sequences.
xe?L,S-W/z	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a sequence diagram best for?	A sequence diagram captures time-ordered messages among participants, highlighting call order, synchrony/asynchrony, and overlapping executions.
b`uu4&rC%6	Basic	Launch into Computing::Unit 04 - Software Engineering	How is a communication diagram different?	It emphasizes which objects talk to which, numbering messages to show order while de-emphasizing exact timing.
t,11Q<U[)V	Basic	Launch into Computing::Unit 04 - Software Engineering	What do timing and interaction-overview diagrams add?	Timing diagrams plot state over time for participants; interaction-overview diagrams stitch multiple interaction diagrams into a higher-level workflow.
Mo-FcR>W{d	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the focus of low-level design?	According to Chapter 7 of Beginning Software Engineering, the focus of low-level design is to refine the high-level design into detailed guidance that explains how the system’s parts will work and interact, providing enough specificity for developers to begin implementation.
pi/K-QCe:J	Basic	Launch into Computing::Unit 04 - Software Engineering	How does low-level design differ from high-level design?	High-level design focuses on what the system will do and its broad structure, while low-level design focuses on how the system will accomplish those goals, specifying details like classes, database schemas, and internal interfaces.
g3[4wg[Y;5	Basic	Launch into Computing::Unit 04 - Software Engineering	What are some overall design approaches used in low-level design?	According to Chapter 7 of Beginning Software Engineering, overall design approaches include design-to-schedule, design-to-tools, process-oriented design, data-oriented design, object-oriented design, and hybrid approaches that combine elements of multiple methods.
f1!tG3Khog	Basic	Launch into Computing::Unit 04 - Software Engineering	What is design-to-schedule?	Design-to-schedule is an approach where solutions are chosen based on available time and resources, prioritizing simpler or faster implementations when deadlines are tight and refining them in future releases if needed.
Ib&4JB6N?m	Basic	Launch into Computing::Unit 04 - Software Engineering	What is design-to-tools?	Design-to-tools is an approach where features are implemented using existing tools or libraries rather than writing custom code, reducing complexity and ensuring reliability through proven technologies.
_U5U,W,xX	Basic	Launch into Computing::Unit 04 - Software Engineering	What is process-oriented design?	Process-oriented design focuses on the processes the system will perform, identifying the data required to support those processes and often enabling parallel execution for scalability.
wC<Di-)$CF	Basic	Launch into Computing::Unit 04 - Software Engineering	What is data-oriented design?	Data-oriented design emphasizes the structure and relationships of the data itself, considering how data will be stored, accessed, and grouped together for efficiency.
"j#~Kl4P/;3"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is object-oriented design?	Object-oriented design defines classes that represent entities, their properties, methods, and events, organizing the system around reusable and modular components that mirror real-world or conceptual objects.
mIrONm;_]_	Basic	Launch into Computing::Unit 04 - Software Engineering	Why might hybrid design approaches be useful?	Hybrid design approaches are useful because combining process-, data-, and object-oriented methods can refine each other, leading to a more complete and flexible design than relying on one method alone.
ife>2J^n5X	Basic	Launch into Computing::Unit 04 - Software Engineering	What is stepwise refinement in design?	Stepwise refinement is the process of breaking down tasks into progressively smaller and more detailed steps until they are simple enough to implement directly in code.
r)PDKyY|x(	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the three main members of a class in object-oriented design?	The three main members of a class are properties (data that defines the object), methods (actions the object can perform), and events (signals that something has occurred).
o2nO22Dr]p	Basic	Launch into Computing::Unit 04 - Software Engineering	What is inheritance in object-oriented design?	Inheritance allows child classes to reuse code and members defined in a parent class, enabling code reuse and the ability to treat objects as both their specific type and their parent type.
l]o]=,;!jJ	Basic	Launch into Computing::Unit 04 - Software Engineering	What is polymorphism?	Polymorphism is the ability for different classes derived from a common parent to be treated as the parent type, while still allowing each class to implement its own specific behavior.
xhoD,P`&C-	Basic	Launch into Computing::Unit 04 - Software Engineering	What is refinement in inheritance hierarchies?	Refinement is the process of breaking a parent class into child classes to capture meaningful behavioral differences, such as distinguishing between cars with manual and automatic transmissions.
M:THq1E`T<	Basic	Launch into Computing::Unit 04 - Software Engineering	What is overrefinement in class hierarchies?	Overrefinement occurs when a hierarchy is split into too many subclasses to represent property differences rather than behavioral ones, leading to unnecessary complexity and confusion.
tOL0BJ-!/3	Basic	Launch into Computing::Unit 04 - Software Engineering	What is generalization in inheritance hierarchies?	Generalization is the process of creating a parent class to capture common features of multiple child classes, allowing shared functionality and polymorphism.
lLQ4+<QNl[	Basic	Launch into Computing::Unit 04 - Software Engineering	What are warning signs of a poor inheritance hierarchy?	Warning signs include hierarchies that are too tall, too many unnecessary classes, single-child subclasses, uninstantiated classes, illogical groupings, and classes representing property values rather than behaviors.
dm^}`(/7v-	Basic	Launch into Computing::Unit 04 - Software Engineering	What is object composition?	Object composition builds complex classes by including instances of other classes as properties, promoting code reuse without forcing illogical inheritance relationships.
MVoyj6V4d&	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a relational database?	A relational database stores related data in structured tables, where rows represent records, columns represent fields, and relationships connect data across tables using keys.
Ak)>Xg>,Zp	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a foreign key?	A foreign key is a field in one table whose value uniquely identifies a record in another table, linking child and parent tables to maintain relationships and data integrity.
"JzM6=N)#9K"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a lookup table?	A lookup table is a table used to validate inputs and configure applications by providing allowable values for fields, often linked through foreign keys.
OZ@$ZvZ1J7	Basic	Launch into Computing::Unit 04 - Software Engineering	What are database anomalies?	Database anomalies are problems like duplicate data, deletion dependencies, and insertion restrictions that occur when a database is not properly normalized.
"A4@120MJL#"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is database normalization?	Database normalization is the process of organizing database tables to reduce redundancy and dependency issues, improving consistency and integrity.
xRXunJ=bXJ	Basic	Launch into Computing::Unit 04 - Software Engineering	What is First Normal Form (1NF)?	First Normal Form requires that each table column has a unique name, each column contains atomic values of a single data type, no two rows are identical, and there are no repeating groups.
vMnum+o@,3	Basic	Launch into Computing::Unit 04 - Software Engineering	What is Second Normal Form (2NF)?	Second Normal Form requires that a table is in 1NF and that all non-key attributes depend on the whole primary key, not just part of it, eliminating partial dependencies.
g2]0h0!0+5	Basic	Launch into Computing::Unit 04 - Software Engineering	What is Third Normal Form (3NF)?	Third Normal Form requires that a table is in 2NF and that non-key attributes do not depend on other non-key attributes, eliminating transitive dependencies.
d1d&C^jgNb	Basic	Launch into Computing::Unit 04 - Software Engineering	Why do most databases stop at 3NF?	Most databases stop at 3NF because it eliminates the most common anomalies without creating overly complex structures that can make the database harder to use and maintain.
H$b{p1nn-P	Basic	Launch into Computing::Unit 04 - Software Engineering	What is denormalization and why is it sometimes used?	Denormalization is the intentional duplication of data in a database to improve performance or simplify queries, often trading space for speed and ease of access.
k;?:paGBu9	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is premature optimization discouraged?	Premature optimization is discouraged because optimizing too early can lock in design decisions unnecessarily, waste time on non-critical code, and distract from ensuring correctness before performance.
E+ll{ZkE&c	Basic	Launch into Computing::Unit 04 - Software Engineering	What does the 80/20 rule in optimization mean?	The 80/20 rule means that roughly 80 percent of runtime is spent in 20 percent of the code, so optimization should focus on the critical parts that matter most rather than all code equally.
B/!8xYMSM7	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the three main goals of security design?	The three main goals of security design, also called the CIA triad, are confidentiality (keeping data secret), integrity (protecting data from unauthorized modification), and availability (ensuring data is accessible when needed).
"fG#>!0L<Uo"	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is security considered a process rather than a product?	Security is considered a process rather than a product because it requires continuous monitoring, updating, and adaptation to new threats, rather than being something that can be solved once and forgotten.
Lmy..;UA|?	Basic	Launch into Computing::Unit 04 - Software Engineering	What types of security should be considered in high-level design?	According to Chapter 8 of Beginning Software Engineering, high-level design should consider physical security, remote and portable device security, network security, operating system security, application and online application security, data security, and cloud security.
d{dX0Y?[r[	Basic	Launch into Computing::Unit 04 - Software Engineering	What is shift-left security?	Shift-left security is the practice of building security into software design from the earliest stages of development, rather than adding it as an afterthought, ensuring vulnerabilities are addressed early.
QM?5./S3=8	Basic	Launch into Computing::Unit 04 - Software Engineering	What is DevSecOps?	DevSecOps is the integration of security practices into DevOps, embedding security into continuous development and operations workflows.
y!he@JpK+s	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a computer virus?	A virus is malicious code inserted into another program that replicates when the program runs, often disguising itself under misleading names.
oE!@AT@9ao	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a Trojan?	A Trojan is malicious software that hides inside another program but does not replicate; instead, it executes harmful actions such as installing backdoors.
BR:qPLOU-_	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a worm?	A worm is a standalone program that spreads by copying itself across networks, often exploiting vulnerabilities or sending itself via email.
"s#J5KmukyT"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is ransomware?	Ransomware is malware that denies access to data or systems (often by encrypting files) and demands payment to restore access.
s(HM$$V6=N	Basic	Launch into Computing::Unit 04 - Software Engineering	What is spyware?	Spyware is software that secretly collects information, such as keystrokes or passwords, and sends it to an attacker.
y6v>gGCIU3	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a rootkit?	A rootkit is malware that installs at very high privilege (OS kernel, boot code, or even firmware) to hide its presence, tamper with the system, and potentially give an attacker persistent, stealthy control.
dTrK[h8(s)	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a denial-of-service (DoS) attack?	A denial-of-service (DoS) attack floods a server with bogus requests so legitimate requests cannot be processed. A distributed denial-of-service (DDoS) attack does the same using multiple computers, often in a botnet.
e;5zqCcRx*	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a zero-day exploit?	A zero-day exploit is an attack that takes advantage of a software vulnerability before a fix or patch is available.
Kt5k~3C%nU	Basic	Launch into Computing::Unit 04 - Software Engineering	What is phishing?	Phishing is an attack that impersonates trusted sources, such as banks or government agencies, to trick users into revealing sensitive information like passwords or credit card numbers.
K2eXAE46n4	Basic	Launch into Computing::Unit 04 - Software Engineering	What is spoofing?	Spoofing is the act of forging digital identities (such as email headers or IP addresses) to make malicious messages or requests appear legitimate.
kvTfQ1x;.c	Basic	Launch into Computing::Unit 04 - Software Engineering	What is spear phishing?	Spear phishing is a targeted phishing attack personalized for a specific individual or group to make the deception more convincing.
I)[GW5GXus	Basic	Launch into Computing::Unit 04 - Software Engineering	What is whaling?	Whaling is a type of phishing attack that targets high-level executives such as CEOs or CFOs.
o;_^2B@@[	Basic	Launch into Computing::Unit 04 - Software Engineering	What is vishing?	Vishing is voice-based phishing, often using phone calls or voicemails to trick victims into revealing sensitive information.
4Ct$]aScE	Basic	Launch into Computing::Unit 04 - Software Engineering	What is smishing?	Smishing is phishing conducted via SMS or text messaging, attempting to trick users into clicking malicious links or providing information.
si}c$&Qk9w	Basic	Launch into Computing::Unit 04 - Software Engineering	What is angler phishing?	Angler phishing is a phishing attack conducted through social media, often impersonating customer service representatives.
g(Ud+xJ%3!	Basic	Launch into Computing::Unit 04 - Software Engineering	What is social engineering in cybersecurity?	Social engineering is the manipulation of people into revealing information or taking harmful actions, using psychological tactics such as authority, intimidation, urgency, consensus, or false trust.
mM$(^}>APp	Basic	Launch into Computing::Unit 04 - Software Engineering	What are some common signs of a social engineering attack?	Common signs include spelling or grammar errors, unusual sender addresses, urgent demands, “too good to be true” offers, requests for secrecy, generic greetings like “Dear Customer,” and suspicious or shortened links.
h`@j&ew9;d	Basic	Launch into Computing::Unit 04 - Software Engineering	What is crapware?	Crapware, also known as bloatware or junkware, refers to preinstalled adware, spyware, or trial programs that slow down systems and can be difficult to remove.
m3|MP@>OW$	Basic	Launch into Computing::Unit 04 - Software Engineering	What is password stuffing?	Password stuffing is an attack where stolen passwords from one application are reused to gain unauthorized access to other systems where users have reused the same credentials.
m_RI8bx,k;	Basic	Launch into Computing::Unit 04 - Software Engineering	What are some methods to strengthen password security?	According to Chapter 8 of Beginning Software Engineering, methods include using password managers, dongles, multifactor authentication (MFA), and biometric verification.
I.&zat%-pX	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is multifactor authentication (MFA) more secure than passwords alone?	Multifactor authentication adds an extra verification step, such as a code sent to a phone or biometric verification, making accounts 99.9% less likely to be compromised compared to relying on passwords alone.
gz|W~Zz<6F	Basic	Launch into Computing::Unit 04 - Software Engineering	What is user access control?	User access control limits what data and functions different users can access, ensuring users only have permissions necessary for their roles, reducing the risk of abuse or accidental damage.
"yS-g}#(k6+"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the 3-2-1 backup strategy?	The 3-2-1 backup strategy recommends keeping three copies of data, stored on two types of media, with at least one copy stored off-site for disaster recovery.
tP?FH(QrXR	Basic	Launch into Computing::Unit 04 - Software Engineering	What are some common security countermeasures?	Common countermeasures include firewalls, antivirus software, anti-spyware programs, backups, encryption, MFA, and user education.
ci}CH$V5V$	Basic	Launch into Computing::Unit 04 - Software Engineering	What is cyber insurance?	Cyber insurance is coverage that helps organizations recover from cyberattacks by covering costs such as legal counsel, recovery, customer reparations, or even ransom payments, though it cannot restore lost data or reputation.
eS)VZl*f?=	Basic	Launch into Computing::Unit 04 - Software Engineering	What’s the difference between UI and UX?	UI (user interface) is what people see and interact with—buttons, forms, menus—while UX (user experience) is the end-to-end experience and perception of the product, including installation, reliability, data locations, and integrations. A UI is part of the UX, not the whole of it.
f0)lof^j5Y	Basic	Launch into Computing::Unit 04 - Software Engineering	Why separate UX design from programming?	According to Chapter 9 of Beginning Software Engineering, separating UX keeps you focused on what’s best for users rather than what’s easiest for code. It reduces the temptation to let data structures or framework quirks dictate the experience.
J%I=wFuDN+	Basic	Launch into Computing::Unit 04 - Software Engineering	How does hardware platform change UX decisions?	According to Chapter 9 of Beginning Software Engineering, platform drives layout and interaction: screen size determines how much you can show at once; the pointing device (mouse, finger, pen) determines precision and gesture choices; and device performance/network shape perceived responsiveness.
bN$FVShL(X	Basic	Launch into Computing::Unit 04 - Software Engineering	Should one product “seamlessly” target desktop, web, tablet, and phone at once?	According to Chapter 9 of Beginning Software Engineering, start with one platform and do it well; “one-size-fits-all” often becomes one-size-fits-none. Add other platforms later when you can tailor them.
vZv)<]XV{f	Basic	Launch into Computing::Unit 04 - Software Engineering	How do first-class vs. transient apps affect design?	According to Chapter 9 of Beginning Software Engineering, first-class apps (used for hours daily) should favor efficient flows for intermediate/advanced users; transient apps (used rarely) should favor beginner-friendly, self-explanatory flows.
w:WE;hYt5}	Basic	Launch into Computing::Unit 04 - Software Engineering	How should beginners, intermediates, and advanced users be supported?	According to Chapter 9 of Beginning Software Engineering, help beginners with menus, labels, dialogs, and tooltips; help intermediates with toolbars and small icons; help advanced users with keyboard shortcuts and customization—ideally offering multiple ways to do the same task.
xE8_VU~H]M	Basic	Launch into Computing::Unit 04 - Software Engineering	Why provide multiple ways to invoke the same command?	Because different users are faster with different affordances: beginners with menus/buttons, intermediates with toolbars, and advanced users with shortcuts. According to Chapter 9 of Beginning Software Engineering, redundancy supports learning and efficiency without forcing one path.
"Rc5Eu||2T#"	Basic	Launch into Computing::Unit 04 - Software Engineering	What’s the right way to use tooltips?	Tooltips should be short “reminders” (e.g., “Watermark”), appearing on hover for discovery without clutter. They help beginners while staying out of intermediates’ way.
nr/))EAKhF	Basic	Launch into Computing::Unit 04 - Software Engineering	What configuration should an app allow—and how should it be saved?	According to Chapter 9 of Beginning Software Engineering, let users configure toolbars/menus, window layouts/docking, fonts/colors, and safe system parameters; auto-save changes immediately and offer “Reset Configuration” to recover from bad setups.
x.>oUL.B46	Basic	Launch into Computing::Unit 04 - Software Engineering	What is “hidden configuration,” and why remember it?	According to Chapter 9 of Beginning Software Engineering, hidden configuration means remembering incidental choices (e.g., last-used tab, splitter positions, column widths) so dialogs/forms reopen in the user’s preferred state, reducing friction.
y6y)Mqs2BP	Basic	Launch into Computing::Unit 04 - Software Engineering	Why design to users’ mental models instead of implementation models?	According to Chapter 9 of Beginning Software Engineering, users reason by outcomes (“files go to the recycle bin”), not by internals; mapping the UI to their mental model makes tasks intuitive even if the model is metaphorical.
eAlo&jcg(~	Basic	Launch into Computing::Unit 04 - Software Engineering	Metaphors vs. idioms—when should each be used?	According to Chapter 9 of Beginning Software Engineering, metaphors (e.g., a trash can) are great for initial understanding, but idioms (e.g., a floppy icon meaning “Save”) are often better long-term because they’re compact, memorable, and don’t constrain new capabilities.
mND=8*E%}G	Basic	Launch into Computing::Unit 04 - Software Engineering	What’s the critique of the ribbon-heavy design in word processors?	According to Chapter 9 of Beginning Software Engineering, large, verbose ribbons favor beginners but waste space and slow intermediates; concise menus/toolbars and discoverable shortcuts better serve frequent users. Customization and reset options help, but inconsistent controls impede efficiency.
lTS.)q,L;z	Basic	Launch into Computing::Unit 04 - Software Engineering	How do we make an app safely explorable?	Provide Undo/Redo so users can try actions and back out. According to Chapter 9 of Beginning Software Engineering, deep undo stacks (and training data where needed) let users learn without fear.
ta3ezVG:BV	Basic	Launch into Computing::Unit 04 - Software Engineering	What is “nonlinear undo,” and what’s a “scrapyard”?	According to Chapter 9 of Beginning Software Engineering, nonlinear undo lets you undo/redo specific actions out of order; a “scrapyard” keeps undone items around so you can reapply them later—like a persistent, non-clearing redo list.
IfXK-%UuR}	Basic	Launch into Computing::Unit 04 - Software Engineering	What does “make the interface immutable” mean in practice?	According to Chapter 9 of Beginning Software Engineering, don’t hide or relocate controls as state changes; disable (gray out) instead. Keep shortcuts consistent and avoid buttons whose labels/meanings morph mid-flow.
Mi|5>>Y/[,	Basic	Launch into Computing::Unit 04 - Software Engineering	What is “commensurate difficulty”?	According to Chapter 9 of Beginning Software Engineering, make easy, frequent, safe, undoable actions quick (e.g., print to default printer), and make rare, slow, dangerous, or irreversible actions take more deliberate steps (and be clearly labeled).
eBQ^u}5%u4	Basic	Launch into Computing::Unit 04 - Software Engineering	Why avoid hidden modes and confusing state?	Modes change meanings unexpectedly. According to Chapter 9 of Beginning Software Engineering, if a mode is unavoidable, make it glaringly obvious so users don’t misinterpret the UI.
vd`U/cH4Ay	Basic	Launch into Computing::Unit 04 - Software Engineering	How do you make similar things similar and different things different?	According to Chapter 9 of Beginning Software Engineering, use consistent grammar, order, and visuals; amplify anomalies with multiple cues (text/icon/shape, not color alone) to aid scanning and support users with color-vision deficiencies.
ChK<7z-O~P	Basic	Launch into Computing::Unit 04 - Software Engineering	When should commands be redundant vs. sparse?	According to Chapter 9 of Beginning Software Engineering, common, safe actions should be available via multiple affordances; dangerous or complex actions can be fewer-path to reduce accidents.
fD<$y2!o]K	Basic	Launch into Computing::Unit 04 - Software Engineering	What does “Do the Right Thing” mean for defaults?	According to Chapter 9 of Beginning Software Engineering, default common actions (e.g., print current document to default printer) without interrogating users each time; offer a separate configuration surface, templates, and duplication to speed setup when defaults don’t fit.
ci$+d<NLUJ	Basic	Launch into Computing::Unit 04 - Software Engineering	How should qualitative and quantitative data be shown?	Show qualitative trends with visuals (e.g., a battery icon) and provide precise numbers on demand (e.g., a tooltip “32%”). According to Chapter 9 of Beginning Software Engineering, this gives fast comprehension plus detail when needed.
MTJgg7n]1G	Basic	Launch into Computing::Unit 04 - Software Engineering	Why minimize dialogs—and which are justified?	According to Chapter 9 of Beginning Software Engineering, dialogs interrupt flow. Prefer status messages and undo over confirmations; only interrupt for severe, unsolvable, irreversible issues that require immediate attention.
H?gb=.u{_r	Basic	Launch into Computing::Unit 04 - Software Engineering	How should information be gathered before long tasks?	According to Chapter 9 of Beginning Software Engineering, collect all inputs up front on one form and then run the task uninterrupted; avoid drip-feed wizards and mid-process questions that stall progress.
OcNsi69bL8	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the “five-second rule” for interactions?	According to Chapter 9 of Beginning Software Engineering, interactive steps should complete within ~5 seconds or users disengage. For longer work, run in the background, show progress, and notify on completion.
k*|DRt_@~x	Basic	Launch into Computing::Unit 04 - Software Engineering	How should background tasks communicate progress?	According to Chapter 9 of Beginning Software Engineering, provide visible, frequently updating progress with status and ETA; allow users to keep working while tasks complete.
Dk,nR^fRDD	Basic	Launch into Computing::Unit 04 - Software Engineering	What does “Only allow what’s right” mean for inputs?	Constrain choices with controls (pickers, sliders, combo boxes) to prevent illegal values. According to Chapter 9 of Beginning Software Engineering, when constraints would be painful, allow direct entry alongside a picker and validate gently.
v}Xu`58O(w	Basic	Launch into Computing::Unit 04 - Software Engineering	How should invalid entries be handled without breaking flow?	Flag issues inline (color, icon, tooltip) and let users continue, correcting later if needed. According to Chapter 9 of Beginning Software Engineering, unobtrusive validation (e.g., an error icon) is preferable to blocking dialogs.
uRDIEsK[lW	Basic	Launch into Computing::Unit 04 - Software Engineering	Why prefer standard controls over custom gizmos?	Standard controls come with learned behavior and accessibility. According to Chapter 9 of Beginning Software Engineering, use them consistently and avoid repurposing controls (e.g., checkboxes shouldn’t trigger actions).
rEVKgeT/W_	Basic	Launch into Computing::Unit 04 - Software Engineering	How should tabs and layout containers be used?	According to Chapter 9 of Beginning Software Engineering, use tabs/containers to group related controls; on wide screens consider vertical tabs to save vertical space; on phones, keep tab counts small and order meaningfully if scrolling is required.
p:vtRNnj,U	Basic	Launch into Computing::Unit 04 - Software Engineering	What are “commanding” controls like split buttons and smart tags?	Split buttons execute a default action and offer a drop-down to pick a new default; smart tags are small affordances attached to controls for quick related actions. According to Chapter 9 of Beginning Software Engineering, both speed repeated tasks when learned.
AvfIFl|6nw	Basic	Launch into Computing::Unit 04 - Software Engineering	How should selection controls be chosen and grouped?	Check boxes are independent toggles; radio buttons are mutually exclusive within a visible group (framed or clearly separated). Keep their appearances distinct and consistent so users don’t confuse them.
"m8;h9FlO#{"	Basic	Launch into Computing::Unit 04 - Software Engineering	What are common pitfalls with “entering” controls?	Over-constrained masked fields can fight users (e.g., time formats inserting colons mid-typing). According to Chapter 9 of Beginning Software Engineering, let users type freely and validate on commit when strict masks cause friction.
Qm.e,GYS=`	Basic	Launch into Computing::Unit 04 - Software Engineering	What does “Display five things” imply for information density?	According to Chapter 9 of Beginning Software Engineering, people can focus on about five items at once; use grouping, ordering, and hierarchy to make large sets scannable (e.g., categorize menus, sort lists).
boBEbzzm4]	Basic	Launch into Computing::Unit 04 - Software Engineering	How should controls be arranged for faster use?	According to Chapter 9 of Beginning Software Engineering, follow natural reading order (typically left-to-right, top-to-bottom), group related items with whitespace/frames, and avoid awkward columnar sequences that fight scanning.
HPocJT.S.F	Basic	Launch into Computing::Unit 04 - Software Engineering	How can Undo/Redo replace confirmations and previews?	If actions are undoable, you can skip “Are you sure?” and preview dialogs; a non-modal status with an Undo option keeps users in flow. According to Chapter 9 of Beginning Software Engineering, this reduces interruptions and speeds work.
M-ac6X$g|L	Basic	Launch into Computing::Unit 04 - Software Engineering	What’s a good strategy for beginner-to-intermediate progression?	Seed the UI with clear labels and tooltips; mirror icons between menus and toolbars; show shortcut hints (e.g., “Ctrl+S”) so users naturally graduate to faster methods. According to Chapter 9 of Beginning Software Engineering, this accelerates skill growth.
igj,^)H6>k	Basic	Launch into Computing::Unit 04 - Software Engineering	When should you let users customize heavily?	According to Chapter 9 of Beginning Software Engineering, allow safe personalization (layouts, toolbars, shortcuts) and provide admin-only settings for global parameters; always persist changes immediately and offer reset options.
"M],#*X;<|0"	Basic	Launch into Computing::Unit 04 - Software Engineering	How do you make status anomalies obvious without relying on color alone?	Combine text, icon, and shape (e.g., “NOT ENABLED” with a red X) and consider capitalization or background tint. According to Chapter 9 of Beginning Software Engineering, multiple cues aid scanning and accessibility.
o=g[V=J.m?	Basic	Launch into Computing::Unit 04 - Software Engineering	Why avoid changing shortcuts or overloading them contextually?	Consistency builds muscle memory; Ctrl+S should always save, not sometimes print or search. According to Chapter 9 of Beginning Software Engineering, changing meanings across contexts causes costly errors.
iK,.ydZBJ4	Basic	Launch into Computing::Unit 04 - Software Engineering	What’s the single most important mindset for writing code?	The single most important mindset for writing code is to write it for people, not computers. According to Chapter 10 of Beginning Software Engineering, clarity is more valuable than cleverness because maintenance and debugging dominate the total cost and risk of software.
m6*hr/nu;D	Basic	Launch into Computing::Unit 04 - Software Engineering	Why should a team invest in good developer hardware?	A team should invest in good developer hardware because fast CPUs, ample RAM, and SSDs reduce compile and run delays that break focus. According to Chapter 10 of Beginning Software Engineering, saving even small amounts of developer time quickly repays hardware costs given programmer hourly rates.
ei^HbO>KZI	Basic	Launch into Computing::Unit 04 - Software Engineering	How does Internet access help programmers?	Internet access helps programmers because quick web searches, documentation, and examples can turn hours of trial-and-error into minutes. According to Chapter 10 of Beginning Software Engineering, teams should provide fast, open Internet access while discouraging obvious time sinks.
"i![n#:MO*G"	Basic	Launch into Computing::Unit 04 - Software Engineering	What tools belong in a modern IDE/toolchain?	A modern IDE/toolchain should include a compiler or interpreter, debugger, profiler, static analysis, automated testing, source control, code formatting, and refactoring support. According to Chapter 10 of Beginning Software Engineering, providing these tools saves time and reduces bugs.
oX.YiS>jRd	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is source control non-negotiable?	Source control is non-negotiable because it tracks every change, enables rollback when a change breaks behavior, supports collaboration without conflicts, and protects against accidental deletion. According to Chapter 10 of Beginning Software Engineering, source control is even more critical for code than document management is for documents.
q|}RD+-Gfg	Basic	Launch into Computing::Unit 04 - Software Engineering	What do profilers do, and when should you use them?	Profilers reveal where time, memory, and I/O are actually spent so you can target true bottlenecks. According to Chapter 10 of Beginning Software Engineering, profilers should be used before optimization because most runtime is concentrated in a small fraction of the code.
d,7G8KiL0@	Basic	Launch into Computing::Unit 04 - Software Engineering	What’s the role of static analysis tools?	The role of static analysis tools is to inspect code without running it, flagging complexity, risky coupling, and maintainability issues. According to Chapter 10 of Beginning Software Engineering, they surface problems early enough to be fixed cheaply.
B0FqIADQkw	Basic	Launch into Computing::Unit 04 - Software Engineering	Why encourage automated testing even before the “Testing” phase?	Automated testing should be encouraged before the formal “Testing” phase because bugs are cheapest to find immediately after they are written. According to Chapter 10 of Beginning Software Engineering, testing early and often helps prevent mistakes from propagating.
pU!{o7:mrH	Basic	Launch into Computing::Unit 04 - Software Engineering	How do code formatters help quality?	Code formatters help quality by enforcing consistent indentation, brace matching, syntax highlighting, and foldable regions, which makes logic easier to follow and reduces bugs. According to Chapter 10 of Beginning Software Engineering, uniform style prevents code from becoming unreadable.
O1U=+{_I]p	Basic	Launch into Computing::Unit 04 - Software Engineering	When are refactoring tools especially valuable?	Refactoring tools are especially valuable when working with existing code because they make it safer to extract methods, rename symbols, and restructure classes without breaking behavior. According to Chapter 10 of Beginning Software Engineering, refactoring tools increase maintainability with less risk than manual edits.
c+I<>F+{NR	Basic	Launch into Computing::Unit 04 - Software Engineering	Why spend money on training?	Spending money on training is important because even a modest training budget quickly pays back in developer effectiveness and retention. According to Chapter 10 of Beginning Software Engineering, a single new technique from a course or book can save hours repeatedly.
gfHg$VLX^i	Basic	Launch into Computing::Unit 04 - Software Engineering	What collaboration capabilities matter for partially remote teams?	Collaboration capabilities that matter for partially remote teams include chat, voice, video, screen sharing, and co-editing. According to Chapter 10 of Beginning Software Engineering, these tools support communication and review but must be balanced to avoid harming focus.
z~Y4>ia41=	Basic	Launch into Computing::Unit 04 - Software Engineering	What is an algorithm in this context, and why not reinvent it?	An algorithm in this context is a known step-by-step method for solving a class of problems such as sorting, routing, or encryption. According to Chapter 10 of Beginning Software Engineering, researched algorithms often reduce intractable problems to seconds-long solutions, so developers should reuse rather than reinvent them.
q@D-4E@eur	Basic	Launch into Computing::Unit 04 - Software Engineering	What is top-down design?	Top-down design, also called stepwise refinement, is the process of breaking a big task into smaller tasks and sub-tasks until coding each step is straightforward. According to Chapter 10 of Beginning Software Engineering, repeated chores should be factored into shared methods as part of refinement.
w=^%sU%BT^	Basic	Launch into Computing::Unit 04 - Software Engineering	How do you know when to stop refining and start coding?	You know to stop refining and start coding when a well-trained developer could implement each step mechanically from the outline. According to Chapter 10 of Beginning Software Engineering, reaching this “painful detail” level makes translation to code nearly automatic.
wu7CK7lrrB	Basic	Launch into Computing::Unit 04 - Software Engineering	How should you handle long, detailed substeps discovered in top-down design?	Long, detailed substeps should be extracted into named helper methods and replaced with clear method calls. According to Chapter 10 of Beginning Software Engineering, this approach keeps the main flow readable and promotes reuse.
fA`Un6J^MN	Basic	Launch into Computing::Unit 04 - Software Engineering	What’s “comment-first” and why does it work?	Comment-first is the practice of writing intent-focused comments before code, then filling in the code between them. According to Chapter 10 of Beginning Software Engineering, this works because comments that explain purpose avoid becoming stale or redundant, unlike comments that simply narrate code.
v`~&{h!w$.	Basic	Launch into Computing::Unit 04 - Software Engineering	What’s the right level of commenting?	The right level of commenting is to explain what the code is supposed to do and why, not to restate how it works line by line. According to Chapter 10 of Beginning Software Engineering, intent comments age well, while code-as-English comments quickly become misleading.
vcwpPsCyhD	Basic	Launch into Computing::Unit 04 - Software Engineering	What is self-documenting code?	Self-documenting code is code that uses descriptive names, avoids magic numbers by using constants or enums, and employs straightforward control flow. According to Chapter 10 of Beginning Software Engineering, this makes code understandable without excessive comments.
"xsf?4]bJ#}"	Basic	Launch into Computing::Unit 04 - Software Engineering	How small should functions be?	Functions should be small enough to fit in working memory and on a single screen. According to Chapter 10 of Beginning Software Engineering, if a method grows unwieldy, it should be split unless performance or tight coupling makes that impractical.
Nc-4uEF/?K	Basic	Launch into Computing::Unit 04 - Software Engineering	When are trailing brace comments useful?	Trailing brace comments are useful when a closing brace is far from its opening brace, such as in deeply nested loops. According to Chapter 10 of Beginning Software Engineering, they should be used sparingly and only when they truly aid navigation.
bj:^)-Hy00	Basic	Launch into Computing::Unit 04 - Software Engineering	What does “stay focused” mean for classes and methods?	“Stay focused” means each class should model one clear concept and each method should do one clear thing. According to Chapter 10 of Beginning Software Engineering, if a class or method cannot be described in one sentence, it is likely trying to do too much.
"sO)7#v*+Xo"	Basic	Launch into Computing::Unit 04 - Software Engineering	Why avoid side effects?	Side effects should be avoided because hidden secondary actions make code harder to understand and maintain. According to Chapter 10 of Beginning Software Engineering, side effects should either be made explicit, undone before returning, or separated into their own methods.
bt=F0at:-I	Basic	Launch into Computing::Unit 04 - Software Engineering	How should you validate results?	Results should be validated by adding assertions that check preconditions, postconditions, and invariants during development to catch errors at the source. According to Chapter 10 of Beginning Software Engineering, conditional compilation or debug-only assertions can be used so validation code disappears from release builds.
Q<nYBf>K{W	Basic	Launch into Computing::Unit 04 - Software Engineering	What’s an invariant, and how do you enforce it?	An invariant is a condition that must always hold, such as ensuring an employee always has 40 scheduled hours. According to Chapter 10 of Beginning Software Engineering, invariants can be enforced by assertions before and after the few public methods that can change state.
Qlp*=|k;]E	Basic	Launch into Computing::Unit 04 - Software Engineering	Why write validation code before implementation?	Validation code should be written before implementation because doing so guarantees its existence and reduces bias. According to Chapter 10 of Beginning Software Engineering, this approach ensures developers do not skip checks once they are attached to their implementation.
jd1^NXVp`.	Basic	Launch into Computing::Unit 04 - Software Engineering	What’s “offensive programming” vs. defensive programming?	Offensive programming throws errors or assertions on invalid input, while defensive programming continues running even on bad input. According to Chapter 10 of Beginning Software Engineering, offensive programming is preferable because it makes failures visible rather than hiding them.
o)Lb!kHb~v	Basic	Launch into Computing::Unit 04 - Software Engineering	Why prefer exceptions over error codes?	Exceptions are preferable to error codes because they force handling or crash loudly, whereas error codes are easy to ignore and can propagate garbage. According to Chapter 10 of Beginning Software Engineering, exceptions make failures explicit and reduce silent corruption.
d)a3*oo*>w	Basic	Launch into Computing::Unit 04 - Software Engineering	When should you write exception handlers?	Exception handlers should be written first, catching expected recoverable errors with specific fixes and translating unrecoverable errors into user-meaningful messages. According to Chapter 10 of Beginning Software Engineering, writing them first prevents weak or missing error handling later.
i9:Mg@Octg	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is duplicating code risky?	Duplicating code is risky because it multiplies maintenance effort and can lead to divergence bugs when one copy changes and others do not. According to Chapter 10 of Beginning Software Engineering, shared logic should be extracted into a single method instead.
t)u;M_^Him	Basic	Launch into Computing::Unit 04 - Software Engineering	What’s the rule of thumb for optimization?	The rule of thumb for optimization is to first make the code work, then optimize only if necessary. According to Chapter 10 of Beginning Software Engineering, premature optimization complicates code and should only target actual bottlenecks identified by profiling.
q6C:/p;QGU	Basic	Launch into Computing::Unit 04 - Software Engineering	How do you decide what to optimize?	Deciding what to optimize requires using a profiler to measure performance and focusing only on demonstrated bottlenecks. According to Chapter 10 of Beginning Software Engineering, guessing wastes time and risks making maintainable code worse.
P+*=NJ7&sD	Basic	Launch into Computing::Unit 04 - Software Engineering	When is developer alertness relevant to quality?	Developer alertness is relevant to quality because coding while tired increases defects and hides edge cases. According to Chapter 10 of Beginning Software Engineering, programmers should write code when they are most alert and save less demanding tasks for low-energy times.
GnHV1(Z+V(	Basic	Launch into Computing::Unit 04 - Software Engineering	What’s a practical way to keep methods free of hidden state?	A practical way to keep methods free of hidden state is to require explicit dependency passing or provide idempotent setup methods. According to Chapter 10 of Beginning Software Engineering, this approach makes dataflow visible and predictable.
oOIJaBV{;M	Basic	Launch into Computing::Unit 04 - Software Engineering	How should you structure long-running data-gathering/processing steps while coding?	Long-running data-gathering or processing steps should be structured to collect inputs up front and execute without interruptions. According to Chapter 10 of Beginning Software Engineering, uninterrupted flows simplify testing and reduce hidden bugs.
DRTnF?l72o	Basic	Launch into Computing::Unit 04 - Software Engineering	What’s a simple naming tip for loops?	A simple naming tip for loops is to use conventional names like i and j for indices, but switch to descriptive names such as row, column, x, or y when they add clarity. This strengthens self-documentation and readability.
K@)*!SgUBR	Basic	Launch into Computing::Unit 04 - Software Engineering	How do enums help readability and safety?	Enums help readability and safety by replacing opaque literals with meaningful symbols and restricting values to a known set. According to Chapter 10 of Beginning Software Engineering, this prevents invalid states and improves clarity.
u8.U;*xvI]	Basic	Launch into Computing::Unit 04 - Software Engineering	How should a team prevent tool misuse or overuse?	A team should prevent tool misuse or overuse by approving only necessary tools, testing on user-like hardware, and avoiding always-on collaboration that destroys focus. According to Chapter 10 of Beginning Software Engineering, balance ensures productivity without distraction.
GMSE<]_ODc	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is it worth starting from known algorithms before coding custom logic?	It is worth starting from known algorithms before coding custom logic because established algorithms encapsulate decades of research and are faster and more reliable to adapt than to reinvent. According to Chapter 10 of Beginning Software Engineering, this is especially true for routing, search, scheduling, and encryption.
HnAA&>&GNT	Basic	Launch into Computing::Unit 04 - Software Engineering	How do you turn a narrative requirement into code with top-down design?	A narrative requirement can be turned into code with top-down design by starting with the high-level goal, breaking it into steps, extracting reusable subtasks, and iterating until each step is trivial to implement. According to Chapter 10 of Beginning Software Engineering, this minimizes rework and duplication.
v8s`b*v,8$	Basic	Launch into Computing::Unit 04 - Software Engineering	What kind of comments should accompany complex math or well-known techniques?	Complex math or well-known techniques should be accompanied by brief intent comments and references to external resources rather than detailed essays. According to Chapter 10 of Beginning Software Engineering, this keeps code lean while allowing readers to follow references for depth.
jl!a4jdEks	Basic	Launch into Computing::Unit 04 - Software Engineering	Why should programmers study algorithms?	Programmers should study algorithms because they are used in every application, from simple calculations to complex systems like search engines and artificial intelligence. According to Chapter 11 of Beginning Software Engineering, studying algorithms not only gives access to a library of existing solutions but also trains the brain to consider multiple approaches, analyze techniques, and improve problem-solving skills.
MFs^AI4!lT	Basic	Launch into Computing::Unit 04 - Software Engineering	What does studying algorithms teach you about problem solving?	Studying algorithms teaches that there is rarely only one way to solve a problem. According to Chapter 11 of Beginning Software Engineering, some methods may be faster, simpler, or less memory-intensive than others, and knowing multiple approaches helps programmers choose the most effective one.
EiHTHF+oU~	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a decision tree?	A decision tree is a data structure that represents possible choices and their outcomes as branches leading to solutions. According to Chapter 11 of Beginning Software Engineering, decision trees help model solution spaces, but they can grow very quickly, requiring strategies such as pruning or restructuring to be useful.
jAd|sd9E!J	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the knapsack problem?	The knapsack problem involves selecting items of different weights and values to maximize value without exceeding a weight limit. According to Chapter 11 of Beginning Software Engineering, the problem can be represented with a decision tree where each branch represents including or excluding an item, but the number of possible solutions grows exponentially as the number of items increases.
kB<|+iTLrQ	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the eight queens problem?	The eight queens problem asks how to place eight queens on a chessboard so that no two can attack each other. According to Chapter 11 of Beginning Software Engineering, restructuring the decision tree from “placing queens on squares” to “placing one queen per row” reduces the search space dramatically, making it solvable by computer in seconds instead of centuries.
s_@3RQP=Va	Basic	Launch into Computing::Unit 04 - Software Engineering	What is exhaustive search?	Exhaustive search is the brute-force approach of examining every possible solution to find the best one. According to Chapter 11 of Beginning Software Engineering, this method is simple and guarantees an optimal solution, but it is often too slow for large problems.
JJFy0HH346	Basic	Launch into Computing::Unit 04 - Software Engineering	What is backtracking in algorithms?	Backtracking is the process of exploring one path of a solution space, then retreating and trying alternatives when a dead end is reached. According to Chapter 11 of Beginning Software Engineering, backtracking is often implemented recursively and is useful for problems modeled with decision trees, such as the knapsack problem.
EvEIm!AHp1	Basic	Launch into Computing::Unit 04 - Software Engineering	What is pruning in decision trees?	Pruning is the process of removing nonessential nodes from a decision tree to simplify it and improve generalization to unseen data.
PfX;LhU>5s	Basic	Launch into Computing::Unit 04 - Software Engineering	What is branch and bound?	Branch and bound is a method of pruning decision trees by discarding branches that cannot possibly improve the best known solution. According to Chapter 11 of Beginning Software Engineering, this approach reduces the number of nodes explored by evaluating the maximum possible outcome from a given point.
AmBhPM:Jz1	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a heuristic?	A heuristic is an algorithmic approach that produces good, usable results but does not guarantee the optimal solution. According to Chapter 11 of Beginning Software Engineering, heuristics are often faster and easier to implement than exact methods and are useful when optimal solutions are impractical.
NAS025;H}M	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a greedy algorithm?	A greedy algorithm makes the best local choice at each step in the hope of reaching an overall good or optimal solution. According to Chapter 11 of Beginning Software Engineering, greedy algorithms are fast and sometimes guarantee optimal results, as in the U.S. coin change-making problem.
"KOJ1#I/e<|"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a divide-and-conquer algorithm?	A divide-and-conquer algorithm works by breaking a problem into smaller parts, solving them separately, and combining the results. According to Chapter 11 of Beginning Software Engineering, binary search is a classic example, repeatedly halving the search space until the target is found or eliminated.
QLk1pc6@(t	Basic	Launch into Computing::Unit 04 - Software Engineering	What is recursion in algorithms?	Recursion is when a function calls itself to solve a smaller version of the same problem. According to Chapter 11 of Beginning Software Engineering, recursion is a natural fit for problems like the Fibonacci sequence or factorials, but it requires stopping conditions to avoid infinite loops.
x]+`3q,EQa	Basic	Launch into Computing::Unit 04 - Software Engineering	What is dynamic programming?	Dynamic programming is an approach that stores intermediate results to avoid recalculating them repeatedly. According to Chapter 11 of Beginning Software Engineering, dynamic programming transforms inefficient recursive solutions, such as Fibonacci, into efficient ones by caching results.
D`hxn6N{Zq	Basic	Launch into Computing::Unit 04 - Software Engineering	What is caching in algorithms?	Caching is the practice of storing previously computed or retrieved values so they can be reused instead of recalculated. According to Chapter 11 of Beginning Software Engineering, caching can significantly improve performance, such as reducing file load times from minutes to seconds in large systems.
hgq$*K6=.?	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a randomized algorithm?	A randomized algorithm incorporates randomness to make decisions or explore solutions. According to Chapter 11 of Beginning Software Engineering, randomized algorithms are grouped into Monte Carlo (probably correct), Las Vegas (always correct but variable runtime), and Atlantic City (probably correct and probably fast).
fx6M[y4dmj	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a Monte Carlo algorithm?	A Monte Carlo algorithm produces results with a probability of correctness rather than certainty. According to Chapter 11 of Beginning Software Engineering, repeating the algorithm many times increases confidence in the result, as in Fermat’s primality test.
"Mw#4<4MG}o"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a Las Vegas algorithm?	A Las Vegas algorithm always produces a correct result but may have unpredictable runtime. According to Chapter 11 of Beginning Software Engineering, quicksort is an example, as its performance depends on the initial arrangement of input values.
DtUBFFju8/	Basic	Launch into Computing::Unit 04 - Software Engineering	What is an Atlantic City algorithm?	An Atlantic City algorithm is an approach that is both probably correct and probably fast. According to Chapter 11 of Beginning Software Engineering, these algorithms are relatively rare and mostly found in advanced mathematical contexts.
t`H`<X:=N7	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a state diagram?	A state diagram is a directed graph that models an object or process by representing states as nodes and transitions as links. According to Chapter 11 of Beginning Software Engineering, state diagrams are useful for processes such as login flows, where transitions depend on user inputs and validations.
I4rm4,P21L	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a design pattern in software engineering?	A design pattern is a reusable solution for common problems in software design, often involving classes or object interactions. According to Chapter 11 of Beginning Software Engineering, patterns provide higher-level strategies compared to algorithms, which focus on tactical problem solving.
pLBM19|P9;	Basic	Launch into Computing::Unit 04 - Software Engineering	What are creational design patterns?	Creational design patterns provide ways to create objects. According to Chapter 11 of Beginning Software Engineering, examples include factory method, lazy initialization, object pool, prototype, and singleton.
h:@%&{iji_	Basic	Launch into Computing::Unit 04 - Software Engineering	What are structural design patterns?	Structural design patterns simplify relationships between objects. According to Chapter 11 of Beginning Software Engineering, examples include adapter, composite, decorator, façade, flyweight, module, proxy, and twin.
lo72m<tHDt	Basic	Launch into Computing::Unit 04 - Software Engineering	What are behavioral design patterns?	Behavioral design patterns manage communication and responsibilities among objects. According to Chapter 11 of Beginning Software Engineering, examples include chain of responsibility, command, iterator, mediator, observer, state, strategy, template, and visitor.
r8Oh<DH&y2	Basic	Launch into Computing::Unit 04 - Software Engineering	What is parallel programming?	Parallel programming is the practice of dividing a task into parts that can be executed simultaneously by multiple processors. According to Chapter 11 of Beginning Software Engineering, this approach can dramatically speed up embarrassingly parallel tasks, such as generating fractal images.
Pc);~I7iv&	Basic	Launch into Computing::Unit 04 - Software Engineering	What is artificial intelligence in the context of algorithms?	Artificial intelligence (AI) in the context of algorithms refers to techniques that enable computers to mimic humanlike tasks such as vision, language understanding, or learning. According to Chapter 11 of Beginning Software Engineering, AI encompasses tools like neural networks, natural language processing, and expert systems.
moC{7^Q/w0	Basic	Launch into Computing::Unit 04 - Software Engineering	What is machine learning?	Machine learning is a type of artificial intelligence where a system learns patterns from data and improves without explicit programming. According to Chapter 11 of Beginning Software Engineering, learning systems are especially useful when dealing with poorly understood or complex datasets.
A5X9g%[6Y|	Basic	Launch into Computing::Unit 04 - Software Engineering	What is natural language processing (NLP)?	Natural language processing (NLP) is the ability of computers to understand, interpret, and generate human language. According to Chapter 11 of Beginning Software Engineering, NLP powers tools like chatbots, search engines, and speech recognition systems.
clKm4%5|q8	Basic	Launch into Computing::Unit 04 - Software Engineering	What is an artificial neural network?	An artificial neural network is a computing system inspired by the human brain that processes data through layers of interconnected nodes. According to Chapter 11 of Beginning Software Engineering, neural networks are foundational for deep learning systems.
"CR)YiCv#zj"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is deep learning?	Deep learning is a type of machine learning that uses neural networks with multiple layers to detect increasingly abstract features. According to Chapter 11 of Beginning Software Engineering, deep learning is effective in vision systems, where lower layers detect edges and higher layers detect shapes.
vb2-tg-E?Z	Basic	Launch into Computing::Unit 04 - Software Engineering	What is an expert system?	An expert system is a program that applies a set of rules, usually derived from domain experts, to solve problems or provide guidance. According to Chapter 11 of Beginning Software Engineering, expert systems use a knowledge base of if-then rules and can mimic the reasoning of human experts.
p{SlU{Wu4e	Basic	Launch into Computing::Unit 04 - Software Engineering	What is artificial general intelligence (AGI)?	Artificial general intelligence (AGI) refers to a theoretical form of AI capable of learning and performing any intellectual task that a human can. According to Chapter 11 of Beginning Software Engineering, AGI contrasts with narrow AI, which is designed for specific tasks.
nU`>.?[!97	Basic	Launch into Computing::Unit 04 - Software Engineering	What are some characteristics of a good algorithm?	Some characteristics of a good algorithm are effectiveness in solving the problem, efficiency in time and memory use, predictability in producing consistent results, simplicity for ease of understanding and maintenance, and availability as prepackaged implementations. According to Chapter 11 of Beginning Software Engineering, these features make algorithms more practical and reliable.
bcSb*rJ<!F	Basic	Launch into Computing::Unit 04 - Software Engineering	Why can programmers not always pick their programming language?	According to Chapter 12 of Beginning Software Engineering, programmers often cannot pick their language because of factors such as management or customer requirements, hardware-specific needs, existing team practices, existing tools, compatibility with a domain, legacy projects, or tool constraints.
d^!}vZ5@~U	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the most effective way to produce stable applications quickly?	According to Chapter 12 of Beginning Software Engineering, the most effective way to produce stable applications quickly is usually to stick with the language and tools you and your team already know, since this reduces mistakes, speeds up development, and improves debugging efficiency.
tiYIC+XC^a	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is learning multiple programming languages beneficial?	According to Chapter 12 of Beginning Software Engineering, learning multiple languages helps programmers understand different approaches to solving problems, adopt good habits enforced by some languages, and apply those habits in others, ultimately making them more versatile and skilled.
QPdq6,,|gw	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a first-generation programming language (1GL)?	A first-generation language (1GL) is machine code consisting of binary 0s and 1s that directly control the hardware. According to Chapter 12 of Beginning Software Engineering, early programmers entered 1GL through physical switches, making it tedious and hard to interpret.
n]_3>a4U;A	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a second-generation programming language (2GL)?	A second-generation language (2GL) is an assembly language that uses symbolic instructions like MOV, CMP, or JMP, which closely map to machine code. According to Chapter 12 of Beginning Software Engineering, these programs are efficient and fast but architecture-specific and hard to write or debug.
F|oMtM;J(6	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a third-generation programming language (3GL)?	A third-generation language (3GL) is a higher-level, machine-independent language such as BASIC, C, C++, Java, or Pascal. According to Chapter 12 of Beginning Software Engineering, 3GLs are much easier for humans to understand and often support structured or object-oriented programming.
IW|FIvLcd&	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a fourth-generation programming language (4GL)?	A fourth-generation language (4GL) is a specialized, high-level language designed for specific domains, focusing on collections of data rather than individual pieces. According to Chapter 12 of Beginning Software Engineering, examples include SQL for databases and MATLAB for mathematical modeling.
I<ocNB/`r=	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a fifth-generation programming language (5GL)?	A fifth-generation language (5GL) is designed to solve problems using rules and constraints rather than explicit algorithms. According to Chapter 12 of Beginning Software Engineering, 5GLs are mainly used in artificial intelligence research, as their broader vision of replacing programmers proved impractical.
"l#NXPd8=X|"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the difference between low-level and high-level languages?	Low-level languages are close to machine hardware and include 1GL and 2GL. High-level languages provide greater abstraction and include 3GL, 4GL, and 5GL. According to Chapter 12 of Beginning Software Engineering, low-level languages are efficient but difficult, while high-level languages prioritise ease of programming.
gz+g)t;/SM	Basic	Launch into Computing::Unit 04 - Software Engineering	What are proposed sixth-generation languages (6GLs)?	According to Chapter 12 of Beginning Software Engineering, proposed sixth-generation languages (6GLs) include graphical coding systems such as Scratch and natural language coding tools like GitHub Copilot or Talon. However, they are not widely considered true 6GLs because they do not meaningfully raise abstraction levels.
z1[2@zUW/I	Basic	Launch into Computing::Unit 04 - Software Engineering	What is an integrated development environment (IDE)?	An integrated development environment (IDE) is a program that provides tools to make programming easier, such as code highlighting, auto-completion, profiling, and version control. According to Chapter 12 of Beginning Software Engineering, examples include Visual Studio with extensions for many languages.
N:LD*FF_Y(	Basic	Launch into Computing::Unit 04 - Software Engineering	What are imperative programming languages?	Imperative programming languages are those where programmers issue explicit commands to change the program’s state, such as z = x + y. According to Chapter 12 of Beginning Software Engineering, most 3GLs like C, Java, Python, and Fortran are imperative.
Eh?mJm:IcK	Basic	Launch into Computing::Unit 04 - Software Engineering	What are procedural programming languages?	Procedural programming languages are imperative languages that allow grouping code into procedures, functions, or modules for reuse. According to Chapter 12 of Beginning Software Engineering, examples include C, C++, Java, and Python, while early BASIC was imperative but not procedural.
e>hz$i)&QV	Basic	Launch into Computing::Unit 04 - Software Engineering	What are declarative programming languages?	Declarative programming languages allow programmers to specify the desired result rather than the exact steps to achieve it. SQL is a common example. According to Chapter 12 of Beginning Software Engineering, declarative languages shift the responsibility of optimisation and execution to the language engine.
g`e=`UJrTj	Basic	Launch into Computing::Unit 04 - Software Engineering	What are object-oriented programming languages?	Object-oriented programming languages are those that define classes and create instances (objects) with properties and behaviours. According to Chapter 12 of Beginning Software Engineering, examples include Java, C++, Python, Ruby, and PHP.
j4i%*2[_Wp	Basic	Launch into Computing::Unit 04 - Software Engineering	What are functional programming languages?	"Functional programming languages express programs as mathematical functions and often favour immutability. According to Chapter 12 of Beginning Software Engineering, pure examples include Haskell, while mixed languages with functional features include Java, C#, Python, Lisp, and Scala."
s,Z+8iZ6X(	Basic	Launch into Computing::Unit 04 - Software Engineering	What are specialized programming languages?	Specialized programming languages are tailored for specific domains, such as robotics, hardware design, list processing, or numerical analysis. According to Chapter 12 of Beginning Software Engineering, they are often too narrow to study unless directly relevant to your work.
E6cmcKE)c<	Basic	Launch into Computing::Unit 04 - Software Engineering	What are some basic reasons to learn a new language?	According to Chapter 12 of Beginning Software Engineering, some reasons to learn a new language include joining a new team, working in a specific field, expanding conceptual understanding, adding skills to a resume, finding a new job, or simply exploring out of curiosity.
AdMUh_vx-Y	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is language longevity important?	According to Chapter 12 of Beginning Software Engineering, language longevity matters because some languages fade out of use while others remain widely supported. Choosing a language with broad adoption ensures access to community support, tools, and long-term usefulness.
A_Jv0NXOl?	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the TIOBE index?	The TIOBE index is a ranking system based on programming language popularity as measured by browser search queries. According to Chapter 12 of Beginning Software Engineering, it reflects interest more than actual usage but correlates somewhat with adoption trends.
cME9TsM?m?	Basic	Launch into Computing::Unit 04 - Software Engineering	What are some top programming languages and their uses?	"According to Chapter 12 of Beginning Software Engineering, current top languages include Python (data science, finance, IoT, web), Java (mobile, desktop, web), JavaScript (mobile, web, desktop), C++ (embedded, desktop), C# (games, Windows, AR/VR), SQL (databases), and R (statistical computing)."
LO6$xK{w7^	Basic	Launch into Computing::Unit 04 - Software Engineering	Why should programmers learn assembly language?	According to Chapter 12 of Beginning Software Engineering, learning assembly language is valuable for understanding how hardware works, appreciating modern languages, and connecting with programming’s roots, even though it is difficult and rarely practical today.
Fo@9&8I+X<	Basic	Launch into Computing::Unit 04 - Software Engineering	Why should programmers study Turing machines?	According to Chapter 12 of Beginning Software Engineering, studying Turing machines is useful for understanding computability theory, such as the halting problem, and appreciating the theoretical foundations of computer science.
G.e*D$Vt&J	Basic	Launch into Computing::Unit 04 - Software Engineering	Why should programmers know HTML and SQL?	According to Chapter 12 of Beginning Software Engineering, every programmer should have at least basic knowledge of HTML and SQL because they are so widely used that not knowing them is like driving without recognising road signs.
ggmcCH91<=	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the fundamental axiom of software engineering about bugs?	The fundamental axiom of software engineering about bugs is that all nontrivial programs contain bugs.
uP$q9,<}|^	Basic	Launch into Computing::Unit 04 - Software Engineering	Why can large projects not be expected to ship without bugs?	According to Chapter 13 of Beginning Software Engineering, large projects cannot ship without bugs because even with low bug rates per thousand lines of code, millions of lines guarantee thousands of defects, making complete elimination unrealistic.
Lmp7NG@asn	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the goals of testing?	The goals of testing are to determine whether code meets requirements and whether it works correctly under all possible circumstances, including with any valid inputs.
Qt&%5cL4Hq	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is removing every single bug not always worthwhile?	According to Chapter 13 of Beginning Software Engineering, removing every single bug is not always worthwhile due to diminishing returns, deadlines, unintended consequences, user reliance on bugs, obsolescence of features, and the risk of introducing new bugs.
w}^l{-)x*y	Basic	Launch into Computing::Unit 04 - Software Engineering	What are diminishing returns in bug fixing?	Diminishing returns occur when the effort required to find and remove additional bugs becomes more expensive than the benefit gained from removing them.
E/2/?H(kqS	Basic	Launch into Computing::Unit 04 - Software Engineering	How can deadlines affect bug fixing decisions?	Deadlines may force developers to release software with minor bugs still present, especially when business or marketing pressures require delivery on time.
c/IX>[bi+b	Basic	Launch into Computing::Unit 04 - Software Engineering	Why might fixing a bug have negative consequences?	Fixing a bug can have negative consequences if the change breaks compatibility, forces data conversions, or causes disruption that outweighs the benefit of the fix.
q/J_b$IZwi	Basic	Launch into Computing::Unit 04 - Software Engineering	When is it considered too soon to release a bug fix?	According to Chapter 13 of Beginning Software Engineering, it is too soon to release a fix if users have just received a patch, unless the bug is a security flaw or one that seriously impacts usability.
iJljP:[JN{	Basic	Launch into Computing::Unit 04 - Software Engineering	Why might some users prefer a bug to remain unfixed?	Some users prefer a bug to remain unfixed because they have come to rely on it as a feature, using it in ways not intended by the developers.
wt@Am=U;gn	Basic	Launch into Computing::Unit 04 - Software Engineering	What is an example of obsolescence affecting bug fixes?	An example of obsolescence affecting bug fixes is when bugs in outdated hardware drivers, such as floppy disk controllers, are ignored because the hardware is no longer widely used.
"k@)#qR/=u9"	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is fixing every bug before shipping unrealistic?	Fixing every bug before shipping is unrealistic because testing and debugging never truly end, and waiting for perfection would prevent release altogether.
J_b>1q$>Yo	Basic	Launch into Computing::Unit 04 - Software Engineering	Why might in-house tools be released with known bugs?	In-house tools may be released with known bugs because their usefulness outweighs minor flaws, and coworkers are obligated to use them even if rough around the edges.
r)%ll`|onz	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is fixing bugs dangerous?	Fixing bugs is dangerous because it can lead to incorrect fixes, misunderstanding of the old code, or the introduction of new bugs.
BvbcY82e=e	Basic	Launch into Computing::Unit 04 - Software Engineering	What factors should be considered when prioritizing bugs?	When prioritizing bugs, factors include severity, available workarounds, frequency, difficulty of fixing, and riskiness of the fix.
Iu;^<xU>~&	Basic	Launch into Computing::Unit 04 - Software Engineering	What is unit testing?	Unit testing verifies the correctness of a small piece of code, such as a method or function, often immediately after it is written.
"n.+X1OH#ad"	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is breaking code into smaller units helpful for testing?	Breaking code into smaller units is helpful for testing because it reduces the number of possible paths through the code, making it easier to verify correctness.
BuG5/b*Nu5	Basic	Launch into Computing::Unit 04 - Software Engineering	What is integration testing?	Integration testing verifies that newly written code interacts correctly with existing code and does not break unrelated parts of the program.
Ja:hq?D4B?	Basic	Launch into Computing::Unit 04 - Software Engineering	What is regression testing?	Regression testing verifies that new code or changes have not unintentionally broken existing functionality in the application.
Lu-a0F1u3w	Basic	Launch into Computing::Unit 04 - Software Engineering	Why should regression testing be performed frequently?	Regression testing should be performed frequently because postponing it allows bugs to accumulate, making them harder to identify and fix later.
po?n~t?f,h	Basic	Launch into Computing::Unit 04 - Software Engineering	What is automated testing?	Automated testing uses tools to run predefined tests automatically, compare actual results with expected outcomes, and sometimes simulate user interactions or load conditions.
"Bl@)#T,3PT"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is component interface testing?	Component interface testing focuses on verifying that different components of a system communicate correctly by examining the messages or interactions between them.
GK]pJkD$tc	Basic	Launch into Computing::Unit 04 - Software Engineering	What is system testing?	System testing is an end-to-end evaluation of the whole application to ensure all parts work together under realistic conditions.
A&A-755-!8	Basic	Launch into Computing::Unit 04 - Software Engineering	What is acceptance testing?	Acceptance testing determines whether the finished application meets the customer’s requirements, typically by having users or representatives run through defined use cases.
K.Jhv5>^vY	Basic	Launch into Computing::Unit 04 - Software Engineering	How does acceptance testing differ from system testing?	Acceptance testing differs from system testing because it is performed from the customer’s perspective, while system testing is typically conducted by developers.
xRiB=SALED	Basic	Launch into Computing::Unit 04 - Software Engineering	What is alpha testing?	Alpha testing is the first round of testing by selected customers or independent testers, usually uncovering many bugs before wider release.
CdM&a3$*9s	Basic	Launch into Computing::Unit 04 - Software Engineering	What is beta testing?	Beta testing is the second round of testing after alpha, usually involving more stable software and often used to gather user feedback or build anticipation for a release.
v7w*lnn^Dv	Basic	Launch into Computing::Unit 04 - Software Engineering	What is black-box testing?	Black-box testing evaluates software without knowledge of its internal workings, focusing on outputs for given inputs.
"j``J=#TO3C"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is white-box testing?	White-box testing evaluates software with knowledge of its internal code, designing tests to specifically target known internal structures and potential weaknesses.
g}l/f?%-d5	Basic	Launch into Computing::Unit 04 - Software Engineering	What is gray-box testing?	Gray-box testing combines black-box and white-box approaches by using partial knowledge of a program’s internals to design targeted tests.
K.lwK7x<P)	Basic	Launch into Computing::Unit 04 - Software Engineering	Why should programmers test their own code?	Programmers should test their own code to catch errors before others do, reducing embarrassment and improving overall software quality.
G,=nF=i`Z&	Basic	Launch into Computing::Unit 04 - Software Engineering	Why should someone else also test your code?	Someone else should test your code because they bring a fresh perspective and are less likely to make the same assumptions as the original developer.
l<a9Ul0{oq	Basic	Launch into Computing::Unit 04 - Software Engineering	What is egoless programming?	Egoless programming is the practice of separating personal identity from the code, accepting criticism without defensiveness, and focusing on collective improvement of software quality.
o.`TNzG>U&	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is fixing your own bugs recommended?	Fixing your own bugs is recommended because the original author usually understands the code best and can learn from the mistake to prevent future issues.
b.Wig(,oZJ	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is it important to think before changing code?	It is important to think before changing code because random modifications may hide rather than fix bugs, introduce new issues, and prevent meaningful learning.
"ubjsez#ecZ"	Basic	Launch into Computing::Unit 04 - Software Engineering	Why must developers understand why a bug fix works?	Developers must understand why a bug fix works because otherwise the issue may not truly be resolved and could reappear under different conditions.
hk[Um($}u~	Basic	Launch into Computing::Unit 04 - Software Engineering	What does it mean to fix bugs, not symptoms?	Fixing bugs, not symptoms, means addressing the root cause of an error instead of patching surface-level problems that may recur later.
u(~O|XnB|<	Basic	Launch into Computing::Unit 04 - Software Engineering	Why should you test your tests?	You should test your tests to ensure they correctly identify errors, often by deliberately inserting known bugs to confirm detection.
btqt{D54^h	Basic	Launch into Computing::Unit 04 - Software Engineering	What are some recommended steps after fixing a bug?	Recommended steps after fixing a bug include preventing similar issues, searching for related bugs, checking for hidden issues, reviewing nearby code, and ensuring the fix did not introduce new problems.
C@trzYYNI(	Basic	Launch into Computing::Unit 04 - Software Engineering	What is code coverage in testing?	Code coverage measures the proportion of code executed during testing to ensure all parts of the program are exercised at least once.
K+oby`V:{T	Basic	Launch into Computing::Unit 04 - Software Engineering	What is seeding in bug estimation?	Seeding is the deliberate insertion of artificial bugs into code to measure how many are found during testing, providing an estimate of how many real bugs may remain.
O`7C^GUB1j	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the Lincoln index in bug estimation?	The Lincoln index is a statistical method for estimating total bugs by comparing the overlap between bugs found by two different testers.
EWoE/a1zXs	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a limitation of the Lincoln index?	A limitation of the Lincoln index is that testers often find the same easy bugs, leading to underestimation of the total number of bugs.
n5sO5YZ+g-	Basic	Launch into Computing::Unit 04 - Software Engineering	Why can testing never prove software is bug-free?	Testing can never prove software is bug-free because testing shows only the presence of bugs, not their absence.
jK{^E-]kQx	Basic	Launch into Computing::Unit 04 - Software Engineering	What is deployment in software engineering?	Deployment in software engineering is the process of putting the finished application into the users’ hands so they can use it in real-world conditions.
o30nssE9D!	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is deployment often considered risky?	According to Chapter 14 of Beginning Software Engineering, deployment is risky because software that worked in testing may fail in the real world, and failures at this stage can undermine months or years of development work.
HAahlHdUD!	Basic	Launch into Computing::Unit 04 - Software Engineering	What terms are sometimes used interchangeably with deployment?	Implementation, installation, and release are sometimes used interchangeably with deployment, though each can reflect slightly different perspectives.
CxcD+.b|B9	Basic	Launch into Computing::Unit 04 - Software Engineering	What does project scope mean in deployment?	Project scope in deployment refers to the size and impact of the application, including the number of users, the amount of data, the number of external systems affected, and the overall quantity of code involved.
dvoEvnxfNA	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is deployment of larger projects more difficult?	Deployment of larger projects is more difficult because they contain more components, more dependencies, and more opportunities for small failures to combine into major problems.
oL|UF/0`1U	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the importance of a deployment plan?	According to Chapter 14 of Beginning Software Engineering, a deployment plan is important because it anticipates potential failures, provides workarounds, and ensures smoother recovery when problems occur.
ef;:sQUkC?	Basic	Launch into Computing::Unit 04 - Software Engineering	What should a deployment plan include?	A deployment plan should include a list of steps to follow, possible points of failure for each step, contingency actions or workarounds, and a rollback plan in case deployment must be undone.
"d#{b0rzsty"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a rollback plan in deployment?	A rollback plan is a strategy to undo deployment changes and restore the system to its previous state if the deployment fails or causes unacceptable issues.
Ck()dE73A2	Basic	Launch into Computing::Unit 04 - Software Engineering	"What is the ""point of no return"" in deployment?"	"The ""point of no return"" in deployment is the stage where rolling back becomes harder than continuing, often when users have already been moved to the new system."
i215s!o<z4	Basic	Launch into Computing::Unit 04 - Software Engineering	What is cutover in deployment?	Cutover is the process of moving users from the old system to the new application.
P|cs($&VGB	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the four cutover strategies described in Chapter 14 of Beginning Software Engineering?	The four cutover strategies are staged deployment, gradual cutover, incremental deployment, and parallel testing.
q?*oW,BiD;	Basic	Launch into Computing::Unit 04 - Software Engineering	What is staged deployment?	Staged deployment is when a fully functional staging environment is created to rehearse deployment, test the system realistically, and fix issues before releasing the application to actual users.
ETsI7uD&)c	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the main benefit of staged deployment?	The main benefit of staged deployment is that it reduces the likelihood of major problems during actual deployment by resolving issues in a controlled environment first.
"kAtJfz#ivl"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is gradual cutover?	Gradual cutover is when users are migrated to the new system one at a time or in small groups while others continue using the old system.
L(@{QZ``;K	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the advantage of gradual cutover?	The advantage of gradual cutover is that only a few users are affected if something goes wrong, limiting the impact on overall productivity.
w?,+?J&L1J	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the drawback of gradual cutover?	The drawback of gradual cutover is that the organization may need to run two systems in parallel temporarily, which can cause complications in data management and workflows.
vZvq}WY6%K	Basic	Launch into Computing::Unit 04 - Software Engineering	What is incremental deployment?	Incremental deployment is when features of the new system are released gradually to users rather than delivering the entire system at once.
tZA4(*l{]<	Basic	Launch into Computing::Unit 04 - Software Engineering	When does incremental deployment work best?	According to Chapter 14 of Beginning Software Engineering, incremental deployment works best with iterative development models where features are built and delivered one at a time, but not with large monolithic applications.
"M.3LF<g_A#"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is parallel testing in deployment?	Parallel testing is when some users simulate their work on the new system while others continue to work on the old system, with the old system serving as the official record.
o5(<9S+;a_	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the main drawback of parallel testing?	The main drawback of parallel testing is that it requires extra personnel to perform work that may feel unproductive since it does not directly affect real business operations.
w}YpH/c.2c	Basic	Launch into Computing::Unit 04 - Software Engineering	What are common categories of deployment tasks?	Common categories of deployment tasks include preparing the physical environment, setting up hardware, creating documentation, providing training, installing databases, configuring third-party software, and installing the application itself.
HPUSoxcN;C	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is training important in deployment?	Training is important in deployment because users may resist or struggle with even small changes, and proper training reduces confusion and mistakes.
P6QqjAICDz	Basic	Launch into Computing::Unit 04 - Software Engineering	What are common deployment mistakes?	Common deployment mistakes include assuming everything will work, having no rollback plan, allowing insufficient time, failing to know when to stop, skipping staging, installing too many updates at once, using an unstable environment, and setting an early point of no return.
Q%!x[Kci7f	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is assuming everything will work a mistake?	Assuming everything will work is a mistake because deployments almost always encounter unexpected problems, and failing to plan for them can lead to serious disruption.
QmJOg=1PN%	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is not having a rollback plan dangerous?	Not having a rollback plan is dangerous because it prevents recovery if the deployment fails, leaving users stuck with broken or unstable software.
y73UJkS=CR	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is allowing insufficient time for deployment risky?	Allowing insufficient time is risky because even small delays or unexpected problems can turn a short deployment into one that takes days or weeks.
D(pUup%WJX	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is it important to know when to surrender during deployment?	It is important to know when to surrender during deployment so that small issues do not accumulate into a disastrous outcome; defining conditions to stop and retry helps maintain control.
Cp<{6>znVs	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is skipping staging a common cause of deployment failure?	Skipping staging is a common cause of failure because it prevents identification and resolution of deployment issues before the system reaches real users.
yMV$$L]eeC	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is installing too many updates at once a problem?	Installing too many updates at once is a problem because it increases the chance of conflicts and failures, making troubleshooting more difficult.
dBsZOj/AC0	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is using an unstable environment risky for deployment?	Using an unstable environment is risky because adding a new application to already inconsistent tools and systems only compounds existing problems.
"PUeP#/64:9"	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is setting an early point of no return a mistake?	Setting an early point of no return is a mistake because it removes the ability to roll back changes if late-stage problems occur; delaying this point maximizes flexibility.
mM~,T{fo<V	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the key to avoiding deployment mistakes?	The key to avoiding deployment mistakes is to assume problems will occur, prepare contingency plans, and be ready to roll back or retry when necessary.
rXdZ3!f>(]	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the overall strategy for successful deployment?	The overall strategy for successful deployment is to create a detailed plan, anticipate possible failures, follow the plan, and roll back or retry if major unexpected problems occur.
D=To[),]WY	Basic	Launch into Computing::Unit 04 - Software Engineering	What happens after deployment is complete?	After deployment is complete, the application enters the maintenance phase, during which it serves its intended purpose and developers address bug reports, change requests, and user feedback.
Qv;&pmo@,_	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the purpose of post-project metrics work?	The purpose of post-project metrics work is to analyze what went well and what went poorly so you can encourage the former and reduce the latter on future efforts; metrics make that analysis concrete rather than anecdotal.
Cbnc(FYMs,	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a “defect” in this context?	A defect is any instance where the application does not do what it is supposed to do—this includes both bugs (incorrect code) and changes (the code matches the spec, but the spec was wrong or has evolved).
m2I`4|`,wv	Basic	Launch into Computing::Unit 04 - Software Engineering	Why distinguish between bugs and changes?	Distinguishing between bugs and changes clarifies whether the problem stems from implementation mistakes (bugs) or from incorrect or evolving requirements (changes), which leads to different prevention and process fixes.
EEzy=.a`<3	Basic	Launch into Computing::Unit 04 - Software Engineering	How can defects be grouped by discoverer and why does it matter?	Defects can be grouped by who found them (developers vs. customers); customer-found defects are the most damaging to trust and imply gaps in reviews and tests, so you use this grouping to improve earlier detection.
LuGa_MiBFd	Basic	Launch into Computing::Unit 04 - Software Engineering	What three reflection questions should be asked for each defect?	For each defect you should ask: how could we have avoided it, how could we have detected it sooner, and—if customers found it—how could we have found it before they did?
A%b{Wzzk9)	Basic	Launch into Computing::Unit 04 - Software Engineering	How should you think about defect severity when prioritizing?	You should rate severity by user impact (e.g., data integrity and correctness are highest), focusing first on issues that waste significant user time or have no simple workaround, then medium, and rarely low-severity items.
JpY&Z&d[Ig	Basic	Launch into Computing::Unit 04 - Software Engineering	Why care when a defect was created?	Defects created earlier (e.g., in specification or high-level design) tend to cascade and cause greater downstream damage, so identifying and fixing root causes at those early stages yields outsized benefit.
DLbq=+INmM	Basic	Launch into Computing::Unit 04 - Software Engineering	What is “age at fix” and why group by it?	Age at fix is how long a defect existed before discovery; long-lived defects often indicate blind spots in testing or reviews, so grouping by age highlights where detection must improve.
IZLcLmhr)j	Basic	Launch into Computing::Unit 04 - Software Engineering	How can task type help you find systemic causes of defects?	Group defects by task type (e.g., Specification, Design/Security, UI, Database, Algorithm, I/O, Documentation, Hardware) to reveal clusters that share causes and suggest process fixes in those specific activities.
hXU$E&l2|U	Basic	Launch into Computing::Unit 04 - Software Engineering	What fields belong in a simple defect database and why?	According to Chapter 15 of Beginning Software Engineering, a useful defect record has: Id, Title, Description, Discoverer, Severity, CreationTime, AgeAtFix, TaskType, Avoidance, Detection, and EarlyDetection so queries can expose patterns across importance, origin, and preventability.
k.`~^<RL{9	Basic	Launch into Computing::Unit 04 - Software Engineering	What is an Ishikawa (fishbone) diagram used for?	An Ishikawa diagram maps a defect’s effect to layered causes and contributing factors, helping you trace from symptom to root cause by branching “ribs” of possible causes until true drivers are isolated.
jOqR~Av>Mg	Basic	Launch into Computing::Unit 04 - Software Engineering	How do you build and use an Ishikawa diagram effectively?	According to Chapter 15 of Beginning Software Engineering, put the effect at the “head,” draw a backbone, add rib categories of causes, decompose each rib into contributing factors, then highlight validated causes and cross out non-causes to focus remediation.
"EV#!AGFdhI"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is an “attribute” versus a “metric”?	An attribute is something you can measure (e.g., defect count, LOC); a metric is a raw or computed value you track to understand the project (e.g., defects per week, comments per KLOC).
p96H(XoCPB	Basic	Launch into Computing::Unit 04 - Software Engineering	What is an “indicator” and how is it used?	An indicator is a metric (or combination of metrics) interpreted as a predictor or health signal—e.g., very low comments/KLOC can indicate hard-to-maintain code; indicators guide decisions and process adjustments.
qckkd4L832	Basic	Launch into Computing::Unit 04 - Software Engineering	What two broad things can you do with indicators?	You can use indicators to predict outcomes for the current project (e.g., likely schedule or defect trends) and to improve practices on future projects (e.g., mandate code review time that historically reduces defects).
OAxD5PBnKd	Basic	Launch into Computing::Unit 04 - Software Engineering	What are qualities of good attributes/metrics?	Good metrics are simple, measurable, relevant, objective, and easy to obtain; if an important attribute is hard to measure directly (like customer satisfaction), you should use consistent proxies such as surveys or complaint volume.
A`&JwvdEK/	Basic	Launch into Computing::Unit 04 - Software Engineering	What common objections to metrics should teams address?	Teams often worry metrics are time-consuming, subjective, or will be used punitively; you counter by automating collection where possible, choosing objective measures, and using metrics to guide the work—not to rank individuals.
tRq,xh/&vl	Basic	Launch into Computing::Unit 04 - Software Engineering	How should indicators be communicated to teams?	According to Chapter 15 of Beginning Software Engineering, use indicators as regular, non-punitive feedback—signposts for course correction rather than cudgels—so people remain honest and engaged with the data.
s4hAJ|NiM(	Basic	Launch into Computing::Unit 04 - Software Engineering	Why avoid fixating on a single metric?	Fixating on one metric can distort behavior and miss context; a balanced set prevents gaming (e.g., only chasing LOC growth) and catches contradictions that warrant investigation rather than knee-jerk action.
"c>l)Tq#[7S"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the difference between process and project metrics?	Process metrics are aggregated across many projects to improve how your organization builds software; project (product) metrics track a single project to forecast progress, defects, or schedule outcomes and to set near-term goals.
kEwZ~$:D=X	Basic	Launch into Computing::Unit 04 - Software Engineering	Give an example of process metric use.	According to Chapter 15 of Beginning Software Engineering, if a long-term plot of “code-review hours per KLOC” versus “bugs per KLOC” shows a knee around 1.5–2 hours/KLOC, you can standardize reviews at that level to capture most benefit without overspending.
tu9qi!jSr=	Basic	Launch into Computing::Unit 04 - Software Engineering	Give an example of project metric use.	If three analysts average 10 use cases/day and 20 complex forms each need ~15 use cases, you can target ~300 use cases in ~10 working days and staff or de-risk accordingly.
K($y:I!4xU	Basic	Launch into Computing::Unit 04 - Software Engineering	What are typical input metrics to track?	Common inputs include cost (tools, infra, training, etc.), effort (person-hours), defect discovery rate, and LOC (with consistent counting rules); these reflect investment and activity.
diQ:C[fB94	Basic	Launch into Computing::Unit 04 - Software Engineering	What output/quality metrics are useful but harder to measure?	Functionality, perceived quality, complexity, efficiency, reliability, and maintainability are useful but often proxy-measured via help tickets, surveys, documentation volume/quality, code structure counts, performance baselines, crash rates, and comment density.
jU_}/^@LMe	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is counting lines of code tricky?	LOC depends on rules (do you count comments, blanks, wrapped statements?); inconsistency yields misleading comparisons and invites gaming, so you must define and hold to project-wide counting conventions.
C/;lTr;<MY	Basic	Launch into Computing::Unit 04 - Software Engineering	Why normalize metrics across projects?	Normalization lets you compare projects of different sizes/complexities; without it, a 2-year, 75K-LOC effort will dwarf a 1-month, 1.2K-LOC tool, obscuring productivity and defect density differences.
tW/1af^[G	Basic	Launch into Computing::Unit 04 - Software Engineering	What is size-oriented normalization?	Size-oriented normalization divides by a size measure (e.g., LOC, KLOC, person-months) to yield comparable rates such as LOC/person-month or bugs/KLOC across projects of different scales.
MsY+`j(x:}	Basic	Launch into Computing::Unit 04 - Software Engineering	Show a size-normalization example.	According to Chapter 15 of Beginning Software Engineering, Project Ruction (1,210 LOC, 3 person-months, 6 bugs) vs. Fracas (75,930 LOC, 168 pm, 462 bugs) yields LOC/pm: 403 vs. 452, and Bugs/KLOC: 4.96 vs. 6.08—Fracas produced more LOC per effort but with higher defect density.
d[0CAp+)kN	Basic	Launch into Computing::Unit 04 - Software Engineering	What are limitations of size-oriented metrics?	They require you to know or guess LOC up front, vary by language (assembly vs. Java), and can penalize elegant, shorter solutions—so they’re best used carefully and in context.
o(~+-/FmQt	Basic	Launch into Computing::Unit 04 - Software Engineering	What is function point (FP) normalization?	Function points estimate application complexity from the user’s perspective (what the system does, not how it’s coded) and allow normalization of metrics like defects/FP or effort/FP across languages and implementations.
AN?mxE&iNw	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the five FP item categories you count?	You count Inputs, Outputs, Inquiries, Internal Files, and External Files—the key user-visible functions and data movements that reflect the system’s functional scope.
y,y,tj%W!;	Basic	Launch into Computing::Unit 04 - Software Engineering	How does complexity factor into FP counting?	Each category’s count is weighted by low/medium/high complexity factors; you estimate overall category complexity (e.g., inputs mostly high) and multiply counts by the category’s factor to get a raw FP subtotal.
"G|5O`jn,#="	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the “raw FP” versus “CAV” in FP analysis?	Raw FP is the sum of category counts × their complexity weights; the Complexity Adjustment Value (CAV) is a sum of 14 general system factors (e.g., performance, online data entry, multiple sites) each rated 0–5 to adjust overall complexity.
:CF~=8Zp;	Basic	Launch into Computing::Unit 04 - Software Engineering	List the 14 CAV factors you evaluate.	According to Chapter 15 of Beginning Software Engineering, the 14 are: data communication, distributed data processing, performance, heavily used configuration, transaction rate, online data entry, end-user efficiency, online update, complex processing, reusability, installation ease, operational ease, multiple sites, and facilitate change.
|k)zfiW.`	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the formula for adjusted function points?	Adjusted FP = Raw FP × (0.65 + 0.01 × CAV); the constant and coefficient weight baseline functional size and the adjustment from the general system characteristics.
e<o7ZUxdH2	Basic	Launch into Computing::Unit 04 - Software Engineering	Show a worked FP example.	According to Chapter 15 of Beginning Software Engineering, with Raw FP = 267 and CAV = 42, Adjusted FP = 267 × (0.65 + 0.42) = 267 × 1.07 = 285.69 FP, which you then use for normalized comparisons (e.g., defects/FP).
Ow%e7HlW_&	Basic	Launch into Computing::Unit 04 - Software Engineering	When might teams skip the CAV step?	Some estimation tools accept Raw FP directly, and some teams feel CAV can over-influence results; if you skip CAV, you should be consistent across compared projects and aware of the lost nuance.
t5s5OJJv|Z	Basic	Launch into Computing::Unit 04 - Software Engineering	How should FP be used in practice?	FPs are most meaningful for comparison and normalization (e.g., defects/FP, effort/FP) across similar projects; the absolute FP number has little standalone meaning outside your organization’s history.
o?0aGj&Qq}	Basic	Launch into Computing::Unit 04 - Software Engineering	How do metrics help with risk detection?	Trending metrics (e.g., defect discovery not tapering, LOC/pm below historical band, or CAV-heavy projects with rising rework) surface risks early so you can adjust staffing, scope, or process before slippage compounds.
I<62LJZH4N	Basic	Launch into Computing::Unit 04 - Software Engineering	How can metrics reduce defects?	By correlating practices with outcomes (e.g., targeted review hours/KLOC, unit test coverage, or earlier UX reviews vs. UI-related defects), you can institutionalize the practices that historically prevent bugs.
eU{v+=+`HC	Basic	Launch into Computing::Unit 04 - Software Engineering	How can metrics improve maintenance?	Indicators like comment density, modularity, and documentation volume predict maintainability; when they’re low, you can budget refactoring/documentation sprints to avoid future slowdowns.
"wr&z@4!<{#"	Basic	Launch into Computing::Unit 04 - Software Engineering	Why must you compare “like with like” when applying indicators?	Indicators are most reliable on projects similar in domain, methodology, language, and team profile; you can still use them elsewhere, but you should watch how well they predict and recalibrate expectations accordingly.
kv[mPHOF$f	Basic	Launch into Computing::Unit 04 - Software Engineering	How should managers avoid abusing metrics?	According to Chapter 15 of Beginning Software Engineering, don’t weaponize metrics against individuals or pile on tracking when projects struggle; instead, talk with the team, reduce busywork, and use metrics as guidance, not punishment.
KPyJAPRWtK	Basic	Launch into Computing::Unit 04 - Software Engineering	Why do wrap-up celebrations matter at the end of a project?	End-of-project celebrations help team morale and closure, reinforcing that people and culture matter alongside delivery; they’re intentionally not post-mortems or stealth performance reviews.
n1tX)iNq2m	Basic	Launch into Computing::Unit 04 - Software Engineering	What are best practices for a wrap party?	According to Chapter 15 of Beginning Software Engineering, keep it social (not a metrics meeting with cupcakes), celebrate shared effort, and save defect analysis and metrics reviews for a separate, focused session.
Bh(pT!(b7l	Basic	Launch into Computing::Unit 04 - Software Engineering	How can “comments per KLOC” act as an indicator?	Very low comments per KLOC can indicate code that will be harder to understand and maintain; if this signal is historically predictive, you can encourage richer commenting during reviews.
J]r4QwiWff	Basic	Launch into Computing::Unit 04 - Software Engineering	What is an example of an actionable indicator target?	If historical data shows a strong reduction in bugs/KLOC when reviews average ~1.5–2 hours/KLOC, make that a standard review budget and monitor adherence and outcomes.
GWb=;E`Isz	Basic	Launch into Computing::Unit 04 - Software Engineering	How do you prevent metric gaming (e.g., inflating LOC)?	Use multiple, balanced metrics, automate collection, define counting rules up front, and reward outcomes (quality and maintainability) rather than raw activity measures like LOC alone.
zP+>kID`uc	Basic	Launch into Computing::Unit 04 - Software Engineering	Why should you keep normalization units consistent across projects?	Consistency (e.g., always using KLOC, person-months, and the same FP rules) ensures comparisons are meaningful; changing units or counting rules midstream corrupts trend lines and hides real effects.
dG+$]MllFv	Basic	Launch into Computing::Unit 04 - Software Engineering	How do you handle hard-to-quantify attributes like customer satisfaction?	Use proxies such as survey scores, complaint counts, NPS-style likelihood-to-recommend, and time-to-value; track them consistently and interpret trends rather than one-off points.
gX8AL5wvsE	Basic	Launch into Computing::Unit 04 - Software Engineering	What’s a sensible way to estimate unknown LOC for planning?	Use best-/worst-/most-likely scenarios from historical analogs, weight them (e.g., 1:1:3), and adjust for complexity deltas—recognizing the estimate’s uncertainty and revisiting it as scope clarifies.
PoFIKg{pVR	Basic	Launch into Computing::Unit 04 - Software Engineering	What’s the core caution when interpreting any metric?	No single metric captures the whole picture; always couple numbers with context and cross-check against other signals and qualitative insight before making decisions.
sBPM&PW={B	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is maintenance such a large part of software costs?	Maintenance is such a large part of software costs because applications often last much longer than expected, sometimes decades, and modifying old code is harder than writing new code. Maintenance can represent around 75 percent of the total cost of ownership for a project.
xWZ|^;]:@N	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the four main categories of maintenance tasks?	The four main categories of maintenance tasks are perfective tasks (improving or adding features), adaptive tasks (responding to environmental changes), corrective tasks (fixing bugs), and preventive tasks (refactoring to make code more maintainable).
CCk+![t+=b	Basic	Launch into Computing::Unit 04 - Software Engineering	What is an example of why experienced team members help in maintenance?	According to Chapter 16 of Beginning Software Engineering, experienced team members help because they understand the original design decisions and reduce the risk of misguided changes, such as when a maintenance crew once made “improvements” that users forced them to reverse.
MRS(P5}2ld	Basic	Launch into Computing::Unit 04 - Software Engineering	Why does modifying old code often cost more than writing new code?	Modifying old code often costs more than writing new code because maintainers must spend time understanding unfamiliar code, and every change requires not only targeted testing but also regression testing of the whole application to avoid new bugs.
"I#/>W.CI?H"	Basic	Launch into Computing::Unit 04 - Software Engineering	What are perfective maintenance tasks?	Perfective maintenance tasks improve existing features or add new ones, often because users discover new needs, overlooked requirements, or better ways of working after using the application.
"P=O#:8ApA;"	Basic	Launch into Computing::Unit 04 - Software Engineering	What are adaptive maintenance tasks?	Adaptive maintenance tasks update software to keep it usable when its environment changes, such as new operating systems, hardware, databases, or network requirements.
wnO&2RS)&4	Basic	Launch into Computing::Unit 04 - Software Engineering	What are corrective maintenance tasks?	Corrective maintenance tasks are fixes for bugs that were missed or newly discovered after release, ensuring the software functions as intended.
Jcyi:?A:F*	Basic	Launch into Computing::Unit 04 - Software Engineering	What are preventive maintenance tasks?	Preventive maintenance tasks are restructuring efforts like refactoring, clarifying confusing code, removing duplication, or simplifying design to make future maintenance easier and less error-prone.
dD7e,ZmxX{	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the “second system effect”?	According to Chapter 16 of Beginning Software Engineering, the second system effect occurs when developers, having learned from a first version, overload the second with unnecessary features and complexity, making it bloated and inefficient.
C}^p-6*Sdj	Basic	Launch into Computing::Unit 04 - Software Engineering	What does “third time’s a charm” mean in software maintenance?	The phrase “third time’s a charm” reflects that by the third version of an application, developers and users usually understand requirements, usability, and architecture well enough to produce a solid, effective product.
f-zG]kOTz?	Basic	Launch into Computing::Unit 04 - Software Engineering	How can developers avoid the second system and third time’s a charm effects?	Developers can avoid these effects by following disciplined processes—gathering requirements, validating specifications, designing flexible architectures, coding with best practices, testing thoroughly, and using staged deployment.
ze.7&aol$;	Basic	Launch into Computing::Unit 04 - Software Engineering	Why do adaptive tasks often create chain reactions?	Adaptive tasks often create chain reactions because updating one dependency, like a toolkit, may require updating others, such as databases or operating systems, causing cascading incompatibilities.
epSj*k)oX%	Basic	Launch into Computing::Unit 04 - Software Engineering	What strategies help reduce adaptive maintenance problems?	Strategies include minimizing reliance on external tools, controlling upgrades by testing them in isolation before rollout, or following a one-version-behind approach to avoid untested releases.
JzlTXT`nQq	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is ignoring upgrades sometimes risky?	Ignoring upgrades is risky because many modern systems enforce automatic updates, and delaying adaptation can leave systems unsupported or incompatible with new hardware and software.
p47!Pa@TwY	Basic	Launch into Computing::Unit 04 - Software Engineering	Why are bug tracking systems important in maintenance?	Bug tracking systems are important because they prevent bugs from being lost, allow developers to manage bug states, assign responsibility, and provide visibility into project quality and progress.
BCbx{?G^@`	Basic	Launch into Computing::Unit 04 - Software Engineering	What are typical states in a bug tracking system?	Typical bug states include New, Assigned, Reproduced, Cannot Reproduce, Pending, Fixed, Tested, Deferred, Closed, and Reopened, each representing where the bug is in its lifecycle.
"p7pSHZ#}5u"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the risk of companies making bug reporting difficult?	According to Chapter 16 of Beginning Software Engineering, making bug reporting difficult shifts the burden onto users and discourages feedback, leading to unresolved issues and poor product quality.
mc/p]LyU+<	Basic	Launch into Computing::Unit 04 - Software Engineering	What are preventive reasons to refactor code?	Preventive reasons to refactor include clarifying confusing sections with comments, eliminating duplicated code (following the DRY principle), improving flexibility for future changes, rewriting buggy “swarm” modules, and correcting bad programming practices.
A)b1;n3.%P	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is “not invented here” a bad reason to refactor?	“Not invented here” is a bad reason to refactor because disliking someone else’s coding style doesn’t justify rewriting functioning, maintainable, and bug-free code. If it’s good enough, it’s good enough.
rF;S`r`.7C	Basic	Launch into Computing::Unit 04 - Software Engineering	Why should developers be careful about refactoring buggy code?	Developers should be careful because rewriting buggy but functional code risks introducing new bugs. A cost-benefit analysis should weigh the frequency and severity of bugs against the risks of a rewrite.
dH;G(5$_kQ	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the DRY principle and why does it matter for maintenance?	DRY (Don’t Repeat Yourself) says code should not be duplicated. Eliminating duplication reduces future maintenance risks, since a bug fix or change needs to be made only once instead of in multiple places.
F6bX%{uE(X	Basic	Launch into Computing::Unit 04 - Software Engineering	What are some indicators of bad programming practices that may justify refactoring?	Indicators include code that is too long, duplicated, contains deeply nested loops, performs multiple tasks, has vague purposes, requires too many parameters, or fails to use some of its parameters.
LA.,F`<i.6	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the recommended approach for small maintenance tasks?	For small tasks like a one-line bug fix, requirements and design steps can be abbreviated, but testing should never be skipped to ensure changes don’t break other parts of the application.
C~);mr6a,w	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is testing critical in maintenance?	Testing is critical because modifying old code is more likely to introduce new bugs, so thorough testing ensures that fixes or changes don’t destabilize the system.
CBPjYTk,{v	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the role of task execution in maintenance?	Task execution in maintenance follows the same phases as initial development—requirements, design, coding, testing, and deployment—but scaled to the scope of the change.
wTiQon=Eu<	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is maintenance often less enjoyable for programmers?	Maintenance can feel less enjoyable because it often involves debugging, working with unfamiliar or messy legacy code, and making incremental fixes rather than creating entirely new systems.
,PNiI9:G-	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the main idea behind predictive development models?	Predictive development models assume that requirements can be predicted in advance, and the project follows a structured sequence from requirements through design, implementation, testing, and deployment, with the expectation that the final product will match the original specification.
gZHp6~BH5)	Basic	Launch into Computing::Unit 04 - Software Engineering	How do predictive models differ from adaptive models?	Predictive models lock requirements and design early, proceeding linearly, while adaptive models allow requirements and goals to change during development, enabling teams to adjust course as new information emerges.
usD`02mLBw	Basic	Launch into Computing::Unit 04 - Software Engineering	What are indicators that a predictive project may succeed?	According to Chapter 17 of Beginning Software Engineering, predictive projects succeed when there is strong user involvement, a clear and shared vision, limited project size, an experienced team, realistic requirements, and reliance on established technology.
"s3FEBpT}#Q"	Basic	Launch into Computing::Unit 04 - Software Engineering	What are indicators that a predictive project may fail?	According to Chapter 17 of Beginning Software Engineering, predictive projects are likely to fail if requirements are incomplete, unclear, frequently changing, or if resources are insufficient to meet the scope of the work.
f7PN*l=U@=	Basic	Launch into Computing::Unit 04 - Software Engineering	What are advantages of predictive development models?	Advantages of predictive models include predictability of schedule and cost, stability of fixed requirements, potential cost savings, detailed design up front, reduced need for refactoring, the ability to detect and fix bugs early, better documentation, more time for training material preparation, and designs that are easier to maintain.
D!.(}t,FzQ	Basic	Launch into Computing::Unit 04 - Software Engineering	What are disadvantages of predictive development models?	Disadvantages of predictive models include inflexibility to requirement changes, delayed initial releases compared to adaptive models, reliance on Big Design Up Front (BDUF), and risk of wasted effort if requirements prove wrong.
jy[e&ht2EQ	Basic	Launch into Computing::Unit 04 - Software Engineering	What is Big Design Up Front (BDUF)?	Big Design Up Front (BDUF) is the principle in predictive models that all requirements and design decisions must be defined before coding begins, on the assumption that this early investment will save time and cost later in the project.
"P!`8Nu#!~_"	Basic	Launch into Computing::Unit 04 - Software Engineering	When are predictive models most appropriate?	Predictive models are most appropriate for smaller projects with clear, stable requirements, experienced teams, short timescales, and established technologies where requirements are unlikely to change.
D_Lvut7.*V	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the waterfall model?	The waterfall model is a predictive software development model in which each phase—requirements, design, implementation, testing, and deployment—is completed fully before moving on to the next, resembling water flowing down sequential steps.
HwdKuN?PXz	Basic	Launch into Computing::Unit 04 - Software Engineering	What assumptions must hold true for the waterfall model to work well?	The waterfall model works well if requirements are precisely known in advance, free of unresolved high-risk items, stable over time, the team has prior experience with similar projects, and there is sufficient time for sequential completion.
MDUhB1fF$4	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the waterfall with feedback model?	The waterfall with feedback model is a variation of waterfall that allows moving backward to the previous phase when issues are discovered, making it possible to correct mistakes in earlier stages without restarting the whole process.
p7Iit|N/>K	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the sashimi model?	The sashimi model, or overlapping waterfall, allows project phases to overlap like slices of sashimi, enabling teams to work on requirements, design, implementation, and even testing simultaneously, improving productivity and responsiveness.
u%JM_K9^@!	Basic	Launch into Computing::Unit 04 - Software Engineering	What are advantages of the sashimi model?	According to Chapter 17 of Beginning Software Engineering, sashimi’s advantages include allowing specialists to work without waiting for others, supporting exploratory spikes to test feasibility of ideas, and enabling feedback from later phases to refine earlier ones.
z3HXsx-%}l	Basic	Launch into Computing::Unit 04 - Software Engineering	What is incremental waterfall?	Incremental waterfall, also called the multi-waterfall model, delivers software in a series of increments, each built with a waterfall-like process, so functionality grows gradually while allowing reevaluation between increments.
z$~A|E^`Y6	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is incremental waterfall considered partly adaptive?	Incremental waterfall is partly adaptive because at the start of each increment the team can reassess direction and adjust features, though within each increment development proceeds predictively.
P:GWzT8_);	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a refactoring increment in incremental waterfall?	A refactoring increment is an iteration dedicated primarily to cleaning up and restructuring code, improving maintainability and consistency without necessarily adding new features, so future increments are more efficient.
cf0@|)Weo|	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the V-model in software engineering?	The V-model is a predictive model shaped like a “V,” where the left side represents decomposition (requirements to design to implementation) and the right side represents integration (testing, validation, and verification) that correspond to each earlier phase.
Py[./ZoB!W	Basic	Launch into Computing::Unit 04 - Software Engineering	What is decomposition in the V-model?	Decomposition in the V-model is the process of breaking the application down into increasingly detailed tasks, moving from concept through requirements and design down to implementation.
I-0ClRlszX	Basic	Launch into Computing::Unit 04 - Software Engineering	What is integration in the V-model?	Integration in the V-model is the process of working upward from code testing through verification and validation, confirming that the system meets requirements and customer needs at progressively higher levels of abstraction.
k<y%<&4j%S	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the Software Development Life Cycle (SDLC)?	The Software Development Life Cycle (SDLC) is the overall sequence of tasks in a software project, from initiation and requirements through design, coding, testing, deployment, maintenance, and eventual disposal or replacement.
IjFG_<W,Jp	Basic	Launch into Computing::Unit 04 - Software Engineering	What are some tasks included in the SDLC?	According to Chapter 17 of Beginning Software Engineering, SDLC tasks include initiation, concept development, preliminary planning, requirements analysis, high-level and low-level design, development, acceptance testing, deployment, maintenance, review, and disposal.
P3jC1|x!^n	Basic	Launch into Computing::Unit 04 - Software Engineering	How does the SDLC illustrate continuity between projects?	The SDLC illustrates continuity by showing that the end of one project can feed directly into the start of the next, creating a continuous loop of software development, maintenance, and replacement.
r9aL9N^;ai	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the role of initiation in the SDLC?	Initiation is the first stage of SDLC, where a project idea is proposed by a customer, executive, or manager, beginning exploration of its feasibility and potential value.
JWGV*6{s@b	Basic	Launch into Computing::Unit 04 - Software Engineering	What happens in concept development within SDLC?	In concept development, the team explores whether the project is worthwhile by defining the concept, conducting feasibility and cost-benefit analyses, and identifying risks, leading to a go/no-go decision before major resources are committed.
h*R`fLx}h	Basic	Launch into Computing::Unit 04 - Software Engineering	What is preliminary planning in SDLC?	Preliminary planning involves assigning project leaders, defining resources, choosing development models and tools, and setting up tracking systems, creating the foundation for the project’s organization.
H9Jr$G9g(O	Basic	Launch into Computing::Unit 04 - Software Engineering	What happens during requirements analysis in SDLC?	During requirements analysis, the team documents user needs and technical requirements through text, diagrams, use cases, and prototypes, creating a shared understanding of what the application must accomplish.
H[HoCw0XQO	Basic	Launch into Computing::Unit 04 - Software Engineering	What is high-level design in SDLC?	High-level design specifies the system architecture, user interface, security, major subsystems, and data flow, creating a broad blueprint of how the application will function.
Ir-H+3g>hh	Basic	Launch into Computing::Unit 04 - Software Engineering	What is low-level design in SDLC?	Low-level design details how each subsystem and component will be built, providing precise instructions that developers can implement directly in code.
G?T<gS)_<m	Basic	Launch into Computing::Unit 04 - Software Engineering	What is acceptance testing in SDLC?	Acceptance testing is the stage where users test the near-final application to confirm that it meets documented requirements, often revealing overlooked bugs or usability issues before deployment.
gg%/zyq1t-	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the purpose of review in SDLC?	Review in SDLC uses collected metrics to evaluate the success of the project and identify ways to improve development processes for future projects.
P%qjM/a83L	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the final disposal stage in SDLC?	The disposal stage is when the application is retired, data is archived securely, and hardware is decommissioned or destroyed, possibly replaced by new systems.
P(dBw~Du!{	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the main strength of predictive models overall?	The main strength of predictive models is that they provide structured planning, predictability, detailed documentation, and stable deliverables, which can lower costs and ease training if requirements remain stable.
u?Ew{Hs19i	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the main weakness of predictive models overall?	The main weakness of predictive models is that they are inflexible and handle changing or incomplete requirements poorly, often leading to failure if customer needs evolve during development.
ld):!wN^jW	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the key difference between predictive and iterative models?	Predictive models commit to fixed requirements and a long-term plan, while iterative models build applications incrementally, allowing adjustment and refinement after each cycle based on feedback and evolving needs.
l(|c<p;58v	Basic	Launch into Computing::Unit 04 - Software Engineering	Why do predictive models struggle with changing requirements?	Predictive models struggle with changing requirements because they invest heavily in upfront requirements and design, making large shifts costly and often equivalent to restarting the project from scratch.
d,l$(&rB^m	Basic	Launch into Computing::Unit 04 - Software Engineering	How do iterative models handle fuzzy requirements?	Iterative models handle fuzzy requirements by starting with the parts of the system that are clear, then refining or adding features in subsequent cycles as requirements become clearer through feedback and development experience.
mR_!Cz4%9E	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the difference between iterative and incremental development?	Iterative development improves features through cycles of increasing fidelity, while incremental development adds fully implemented features step by step until the system is complete.
f/<gwv^1$_	Basic	Launch into Computing::Unit 04 - Software Engineering	How does agile development combine iteration and incrementality?	Agile development starts with a minimal set of features at low fidelity, then iteratively improves those features while incrementally adding new ones, eventually delivering all features at full fidelity.
F2z+xt<6Pg	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a prototype in software engineering?	A prototype is a simplified model of an application that demonstrates some behaviors or features to explore requirements, design ideas, or technical feasibility, without being a complete final product.
GXZ^[jz1yS	Basic	Launch into Computing::Unit 04 - Software Engineering	What are horizontal and vertical prototypes?	Horizontal prototypes demonstrate many features with little depth, often focusing on user interface, while vertical prototypes demonstrate fewer features but with great depth, often focusing on backend processing or technical feasibility.
c^cf:a%ac7	Basic	Launch into Computing::Unit 04 - Software Engineering	What are throwaway prototypes?	Throwaway prototypes are built quickly to explore or validate requirements and design ideas, then discarded rather than evolving into the final application.
K*zmED|[|V	Basic	Launch into Computing::Unit 04 - Software Engineering	What are evolutionary prototypes?	Evolutionary prototypes start as partial implementations and are refined through successive iterations until they evolve into the final working application.
BPXR)VIs+B	Basic	Launch into Computing::Unit 04 - Software Engineering	What is incremental prototyping?	Incremental prototyping develops separate prototypes for different features, then integrates them into the final system, allowing multiple teams to work in parallel while reusing prototype code in the final product.
cBr@m]`r+t	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the main benefits of prototyping?	According to Chapter 18 of Beginning Software Engineering, the main benefits of prototyping include improved requirements, a shared vision between developers and customers, better design exploration, and early feedback that helps refine the application.
d(0l9=B)aY	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the main risks of prototyping?	According to Chapter 18 of Beginning Software Engineering, prototyping risks include narrowing vision to a single approach, customer impatience to ship prototypes, schedule pressure, raised expectations, attachment to prototype code, and wasting time on unnecessary refinement.
u5Rdmj9l^_	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the spiral model in software development?	The spiral model is a risk-driven, iterative approach introduced by Barry Boehm in 1986 that cycles through planning, risk analysis, engineering, and evaluation, with prototypes and risk resolution guiding each cycle.
"c_y#]bBzj^"	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the four basic phases of each spiral cycle?	The four basic phases of a spiral cycle are planning (define objectives), risk analysis (identify and resolve risks with prototypes), engineering (develop and test solutions), and evaluation (review results with stakeholders).
M2;PY[|{Fl	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the role of risk analysis in the spiral model?	Risk analysis identifies potential threats to achieving objectives, and prototypes or studies are used to resolve those risks before proceeding, making risk management the core driver of spiral development.
lF|ym}<@~j	Basic	Launch into Computing::Unit 04 - Software Engineering	What are Boehm’s six clarified characteristics of spiral cycles?	Boehm’s six characteristics are: define tasks concurrently, consider all stakeholders’ goals, identify and resolve risks, confirm stakeholder agreement, use risk to determine effort, and use risk to determine level of detail.
"iQK$C#bXzp"	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the anchor milestones in the spiral model?	The anchor milestones are Life Cycle Objectives (LCO), Life Cycle Architecture (LCA), and Initial Operational Capability (IOC), which mark agreement on project goals, architecture soundness, and readiness for delivery.
J;ZcRo*e.g	Basic	Launch into Computing::Unit 04 - Software Engineering	What are advantages of the spiral model?	Advantages of the spiral model include strong stakeholder involvement, emphasis on risk management, flexibility to change requirements, and increasingly accurate estimates as cycles progress.
CNfCQhz*Vr	Basic	Launch into Computing::Unit 04 - Software Engineering	What are disadvantages of the spiral model?	Disadvantages of the spiral model include high complexity, resource intensity, difficulty of risk analysis, poor fit for small projects, and reliance on skilled stakeholder participation.
fYJz<=2tdd	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the Unified Process (UP)?	The Unified Process (UP) is an iterative and incremental development framework that divides projects into inception, elaboration, construction, and transition phases, focusing on risks, iterative refinement, and incremental releases.
d$eMn^~6]`	Basic	Launch into Computing::Unit 04 - Software Engineering	What happens in the inception phase of UP?	In inception, the team defines the project’s business case, identifies risks, provides an initial schedule, and sketches high-level goals without constraining developers with unnecessary detail.
i%:%=0=uB{	Basic	Launch into Computing::Unit 04 - Software Engineering	What happens in the elaboration phase of UP?	In elaboration, the team develops requirements, use cases, and architecture diagrams, with iterations aimed at identifying and addressing major risks before construction begins.
v%e9^89ziA	Basic	Launch into Computing::Unit 04 - Software Engineering	What happens in the construction phase of UP?	In construction, the team codes, tests, and debugs the system in increments, delivering high-quality working executables at the end of each iteration, focusing on important features first.
pneNqr_3Wa	Basic	Launch into Computing::Unit 04 - Software Engineering	What happens in the transition phase of UP?	In transition, the system is delivered to customers and maintenance teams, user feedback drives refinements, and supporting tasks such as staging, documentation, and training are completed.
tOI)2`zSjD	Basic	Launch into Computing::Unit 04 - Software Engineering	What are advantages of the Unified Process?	Advantages of UP include iterative refinement, risk-focused elaboration, flexibility to use different models during construction, extensive documentation for onboarding, and potential for incremental releases.
MG/9_?E`I7	Basic	Launch into Computing::Unit 04 - Software Engineering	What are disadvantages of the Unified Process?	Disadvantages of UP include complexity, resource demands, difficulty of risk analysis, and poor fit for small projects where overhead may outweigh benefits.
Jm_XcqFQEW	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the Rational Unified Process (RUP)?	The Rational Unified Process (RUP) is IBM’s commercial version of the Unified Process, including tools, templates, and supporting disciplines such as configuration management, project management, and process customization.
d`c>q*+%wK	Basic	Launch into Computing::Unit 04 - Software Engineering	What are artifacts in RUP?	Artifacts in RUP are intermediate or final results such as documents, models, or model elements produced during the project, including use cases, design models, and deployment plans.
Pt^ds-?o0j	Basic	Launch into Computing::Unit 04 - Software Engineering	What are OpenUP and Agile Unified Process (AUP)?	OpenUP is a lightweight, open-source version of UP tailored for small teams and short projects, while AUP integrates agile techniques like test-driven development into UP and was later superseded by Disciplined Agile Delivery (DAD).
b29a>1=!v?	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the Cleanroom development model?	The Cleanroom model emphasizes defect prevention through formal methods, statistical quality control, and statistical testing to ensure software quality before defects appear in production.
Hvom2hs)]B	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the principles of Cleanroom development?	The principles of Cleanroom include using formal mathematical methods, incremental development with quality measurement, and statistical testing to estimate application quality with confidence.
PWks:G*Lhe	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the pros of Cleanroom?	Pros of Cleanroom include strong emphasis on defect prevention, continuous quality measurement, and the ability to fine-tune development as issues are detected during increments.
P.W(66c!~	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the cons of Cleanroom?	Cons of Cleanroom include the difficulty of applying formal methods, the complexity of statistical testing, and the steep expertise required, making it less practical for many teams.
FY2a4IZ:OR	Basic	Launch into Computing::Unit 04 - Software Engineering	What is cowboy coding?	Cowboy coding is an undisciplined approach where developers control almost all aspects of a project with minimal management oversight, often used in exploratory projects but criticized for unpredictability and lack of rigor.
N7RQPL^U2y	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the main advantage of cowboy coding?	The main advantage of cowboy coding is that it gives experienced developers maximum freedom and creativity to explore ideas quickly without heavy constraints.
tN@2DlS]+u	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the disadvantages of cowboy coding?	Disadvantages of cowboy coding include unreliable schedules, weak customer interaction, poor adaptability, and the risk of chaotic outcomes due to lack of process discipline.
gT@%Xnn+V(	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the overall strength of iterative models?	The strength of iterative models is their ability to refine requirements and design over time, accommodate change, and deliver partial working software earlier, reducing risk of wasted effort.
IQ;Xl4t=Tt	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the overall weakness of iterative models?	The weakness of iterative models is that they may raise unrealistic customer expectations, create schedule pressure, and increase management complexity compared to simpler predictive approaches.
tu;E*;,IV	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the main goal of rapid application development (RAD) models?	According to Chapter 19 of Beginning Software Engineering, the main goal of RAD models is to produce useful software as quickly as possible by incorporating techniques that accelerate development while still delivering value to users.
NLPrZ&UCxK	Basic	Launch into Computing::Unit 04 - Software Engineering	How does RAD differ from earlier software development models?	RAD differs from earlier models because it focuses explicitly on speed, whereas models like waterfall, spiral, and Unified Process emphasise correctness, robustness, or risk management but not rapid delivery.
"w%QCB#H:QY"	Basic	Launch into Computing::Unit 04 - Software Engineering	"What is the difference between ""RAD"" and ""James Martin RAD""?"	"According to Chapter 19 of Beginning Software Engineering, ""RAD"" generally refers to the broader family of rapid development models, while ""James Martin RAD"" refers specifically to the methodology defined by James Martin in his 1991 book *Rapid Application Development*."
vPL`ard[R&	Basic	Launch into Computing::Unit 04 - Software Engineering	Can a RAD tool make a project inherently RAD?	A tool does not make a project inherently RAD. For example, prototyping tools or environments like Visual Studio can be used in RAD or non-RAD projects, so they are not inherently RAD even if they enable rapid development.
u<[<h%s2G@	Basic	Launch into Computing::Unit 04 - Software Engineering	Why do RAD methods emphasise keeping developers happy and productive?	According to Chapter 19 of Beginning Software Engineering, RAD methods emphasise developer satisfaction because code is written for people to read, understand, debug, and maintain. Developers who are motivated and collaborative are more productive, which helps deliver high-quality software quickly.
gqS1SLY{M%	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the principle behind RAD’s handling of change?	RAD is based on the principle that requirements and environments constantly change, so development must use short iterations, frequent feedback, and adaptable planning to keep the project aligned with user needs.
"Q5&#/f<XzI"	Basic	Launch into Computing::Unit 04 - Software Engineering	How does RAD approach iteration compared to traditional iterative models?	According to Chapter 19 of Beginning Software Engineering, RAD takes iteration to the extreme by using cycles as short as a month, a week, or even less, and applies iteration not only to programming but also to requirements gathering, validation, and design.
z.CpRd/6G-	Basic	Launch into Computing::Unit 04 - Software Engineering	What techniques are commonly used for requirements gathering in RAD?	Common RAD requirements gathering techniques include focus groups, workshops, facilitated meetings, prototyping, and brainstorming sessions with active user involvement.
h]5LKK>T^P	Basic	Launch into Computing::Unit 04 - Software Engineering	How are requirements validated in RAD projects?	According to Chapter 19 of Beginning Software Engineering, requirements in RAD are validated through iterated prototypes, use cases, and constant customer testing of evolving designs.
zu?W?QgJ>P	Basic	Launch into Computing::Unit 04 - Software Engineering	"What is meant by ""timeboxing"" in RAD?"	Timeboxing is the practice of setting a fixed delivery schedule for the next iteration or deliverable, where scope can change but the completion date cannot, ensuring rapid and predictable delivery cycles.
HWTvSX<0Ey	Basic	Launch into Computing::Unit 04 - Software Engineering	"What is ""iteration 0"" in agile or RAD projects?"	Iteration 0 is the initial setup phase where teams prepare hardware, tools, environments, and gather basic requirements before delivering iterations. According to Chapter 19 of Beginning Software Engineering, iteration 0 should be kept as short as possible to begin delivering value quickly.
Ja*|]_n1|l	Basic	Launch into Computing::Unit 04 - Software Engineering	What are some advantages of RAD models?	According to Chapter 19 of Beginning Software Engineering, advantages of RAD include more accurate and adaptable requirements, frequent customer feedback, reduced development time, possible early releases, code reuse, risk mitigation, and higher chances of project success.
eDBL6t@$I=	Basic	Launch into Computing::Unit 04 - Software Engineering	What are some disadvantages of RAD models?	Disadvantages of RAD models include resistance to organisational change, difficulty handling large systems, need for skilled teams, dependency on scarce customer resources, reduced managerial control, risk of suboptimal designs, and unpredictability in timelines.
NpzP&.<g44	Basic	Launch into Computing::Unit 04 - Software Engineering	Why do RAD projects sometimes result in suboptimal designs?	RAD projects may result in suboptimal designs because short iterations focus on immediate deliverables. Large or complex designs may not fit into one iteration, leading to incremental compromises rather than holistic optimisation.
FkFb/nt,;g	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a burndown chart?	A burndown chart is a graph that shows the amount of work remaining over time so a team can see whether progress is on track.
HqU8o1lwui	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the difference between a sprint burndown chart and a product burndown chart?	A sprint burndown tracks remaining work for a single sprint, while a product (release) burndown tracks remaining work for the whole project; according to Chapter 19 of Beginning Software Engineering, both visualize scope versus time to guide planning and review.
t4W>?9Z+Mb	Basic	Launch into Computing::Unit 04 - Software Engineering	What units can a burndown chart use to measure work?	A burndown chart can use story points, estimated hours, or any consistent unit the team finds useful; according to Chapter 19 of Beginning Software Engineering, the x-axis can be dates or sprint numbers for release charts.
E]w53*]>{N	Basic	Launch into Computing::Unit 04 - Software Engineering	What is an “ideal burndown” line?	According to Chapter 19 of Beginning Software Engineering, an ideal burndown is a straight-line projection that assumes the team completes an equal amount of work each sprint, used as a baseline for comparing actual progress.
E?=D,hJhjA	Basic	Launch into Computing::Unit 04 - Software Engineering	How should teams use deviations from the ideal burndown?	Teams compare actual to ideal to spot scope churn or under/over-performance and then adjust scope, staffing, or practices; according to Chapter 19 of Beginning Software Engineering, this comparison belongs on the big board so everyone sees it.
"NYSX#q[nmc"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is velocity in scrum?	Velocity is the amount of work a team completes in a sprint, typically summed as delivered story points or finished backlog items; according to Chapter 19 of Beginning Software Engineering, it stabilizes after a few sprints and helps forecast future capacity.
m:*D8F:F8(	Basic	Launch into Computing::Unit 04 - Software Engineering	What events can cause velocity to fluctuate?	According to Chapter 19 of Beginning Software Engineering, small team changes (vacation, illness, adding/removing one person) and changing sprint length can noticeably change velocity on small teams.
EZ*Hmy>BM)	Basic	Launch into Computing::Unit 04 - Software Engineering	Can scrum be combined with other methods?	Yes—according to Chapter 19 of Beginning Software Engineering, scrum focuses on project management, so you can pair it with methods like XP for engineering practices.
mt:dlma{w:	Basic	Launch into Computing::Unit 04 - Software Engineering	What is Lean Software Development in the context of software?	Lean is the application of lean manufacturing principles to building software, aiming to keep the product minimal and focused on customer value.
t3WB@FFnys	Basic	Launch into Computing::Unit 04 - Software Engineering	What does Lean focus on compared to scrum?	According to Chapter 19 of Beginning Software Engineering, Lean emphasizes selecting the right, minimal set of requirements and removing waste in each iteration, while scrum frames timeboxed delivery and roles.
x-woGLtosh	Basic	Launch into Computing::Unit 04 - Software Engineering	What does “Eliminate waste” mean in Lean?	According to Chapter 19 of Beginning Software Engineering, eliminate waste means remove unclear requirements, unnecessary features, repetition, unneeded meetings, and anything not adding customer value.
jk@eOTT8>E	Basic	Launch into Computing::Unit 04 - Software Engineering	What does “Respect the team” mean in Lean?	It means empower a self-organizing team with the authority and trust to work effectively; according to Chapter 19 of Beginning Software Engineering, this support increases throughput and quality.
"kw$m7;Wz@#"	Basic	Launch into Computing::Unit 04 - Software Engineering	What does “Defer commitment” mean in Lean?	According to Chapter 19 of Beginning Software Engineering, defer commitment means postpone decisions until you have enough information, exploring options first instead of prematurely locking designs.
"yxhc-Hb$#A"	Basic	Launch into Computing::Unit 04 - Software Engineering	What does “Deliver quickly” mean in Lean?	It means use frequent short iterations to put value in users’ hands early and often.
t@nkh~-xh!	Basic	Launch into Computing::Unit 04 - Software Engineering	What does “Build knowledge” mean in Lean?	According to Chapter 19 of Beginning Software Engineering, build knowledge via prototypes, early testing, and short cycles that validate assumptions and clarify requirements.
LSO=lAu:I(	Basic	Launch into Computing::Unit 04 - Software Engineering	What does “Build in quality” mean in Lean?	It means continuously validate assumptions, refactor to maintain integrity, and keep the system internally consistent; quality is not “added later.”
oLU~E0Ya[6	Basic	Launch into Computing::Unit 04 - Software Engineering	What does “See the whole” mean in Lean?	According to Chapter 19 of Beginning Software Engineering, cross-functional teams should understand the big picture and fix problems anywhere in the system rather than treating issues as “someone else’s problem.”
pb%859A!O*	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the Crystal family of methodologies?	Crystal is a family of lightweight, people-centric methods by Alistair Cockburn that vary by project size (“colors”) and by criticality; according to Chapter 19 of Beginning Software Engineering, each variant tailors rigor to team size and risk.
pUJY>8[rY!	Basic	Launch into Computing::Unit 04 - Software Engineering	How are Crystal methods named by color and team size?	According to Chapter 19 of Beginning Software Engineering, examples include Crystal Clear (1–6), Yellow (7–20), Orange (21–40), Red (41–80), Maroon (81–200), Diamond (201–500), and Sapphire (501–1,000).
JsI[6ai]{m	Basic	Launch into Computing::Unit 04 - Software Engineering	What does Crystal mean by criticality?	Criticality classifies risk as comfort, discretionary money, essential money, or life, guiding how much formality and testing are required; according to Chapter 19 of Beginning Software Engineering, higher criticality demands more rigor.
x>grWygbx5	Basic	Launch into Computing::Unit 04 - Software Engineering	What seven common features do Crystal methods share?	According to Chapter 19 of Beginning Software Engineering: frequent iterations, constant feedback, constant communication (preferably co-located), safety (psychological, schedule/budget, and domain criticality), focus (protected time and clear priorities), easy access to expert users, and strong testing/CI support.
ilEf[H:ss`	Basic	Launch into Computing::Unit 04 - Software Engineering	How does Crystal scale rigor with size and criticality?	Larger or more critical projects add roles, documentation, tracking, and formal reviews; smaller or low-criticality projects can rely on informal communication and minimal artifacts, per Chapter 19 of Beginning Software Engineering.
BYg+F|e3A.	Basic	Launch into Computing::Unit 04 - Software Engineering	What roles are required in Crystal Clear?	According to Chapter 19 of Beginning Software Engineering, Crystal Clear needs a Sponsor, a Senior Designer, and one or more Programmers; other responsibilities are shared.
M@qh:W$~+g	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the delivery cadence in Crystal Clear?	Crystal Clear aims for production releases every two to three months, with the main progress measure being released software.
KgWaeH9>(Y	Basic	Launch into Computing::Unit 04 - Software Engineering	What practices help coordinate a Crystal Yellow (7–20) project?	According to Chapter 19 of Beginning Software Engineering: easy communication, code ownership by sub-teams, frequent user feedback, automated testing, a clear mission statement, and monthly timeboxed increments.
"gM#[`8m,*S"	Basic	Launch into Computing::Unit 04 - Software Engineering	What additional roles and controls appear in Crystal Orange (21–40)?	According to Chapter 19 of Beginning Software Engineering: add roles like Business Analyst, Project Manager, Architect, and Team Leaders; add formal requirements, tracking, release schedules, object models, code/design reviews, acceptance testing, and staged/incremental deliveries.
fw{3%e6+iJ	Basic	Launch into Computing::Unit 04 - Software Engineering	What is Feature-Driven Development (FDD)?	FDD is an iterative, incremental method designed for large teams that plans and delivers in terms of small, user-valued “features”; according to Chapter 19 of Beginning Software Engineering, it was created for a 50-person, 15-month project.
uyK`]u?RDF	Basic	Launch into Computing::Unit 04 - Software Engineering	What primary roles does FDD define?	According to Chapter 19 of Beginning Software Engineering: Project Manager, Chief Architect, Development Manager, Chief Programmers, Class Owners, and Domain Experts (SMEs).
p-n:z)$)|7	Basic	Launch into Computing::Unit 04 - Software Engineering	How does FDD assign code ownership?	FDD assigns each class to a specific “class owner”; when a feature spans classes, the owners form a feature team to implement it collaboratively, per Chapter 19 of Beginning Software Engineering.
My2=(FmGQi	Basic	Launch into Computing::Unit 04 - Software Engineering	What five phases does FDD use?	According to Chapter 19 of Beginning Software Engineering: Develop a Model, Build a Feature List, Plan by Feature, Design by Feature, and Build by Feature (the last two iterate).
D5><%NfLyq	Basic	Launch into Computing::Unit 04 - Software Engineering	How does FDD define a “feature”?	According to Chapter 19 of Beginning Software Engineering, a feature is an action/result/object triple (e.g., “calculate outstanding balance for customer”).
zEknm=Jd&&	Basic	Launch into Computing::Unit 04 - Software Engineering	How does FDD organize features hierarchically?	Per Chapter 19 of Beginning Software Engineering, features are grouped into Areas (domains), Activities (user goals), and atomic Features; this “feature tree” aids planning and ownership.
I!I=@NCp*4	Basic	Launch into Computing::Unit 04 - Software Engineering	What comes out of “Design by Feature” in FDD?	According to Chapter 19 of Beginning Software Engineering, the team produces a design package: description, sequence diagrams, alternatives, updated object models, and method prologues, validated by a design inspection.
z?[SO*M)w*	Basic	Launch into Computing::Unit 04 - Software Engineering	What happens in “Build by Feature” in FDD?	Class owners implement methods, unit test, undergo code inspection by the chief programmer, and then promote the code to the project build; according to Chapter 19 of Beginning Software Engineering, iterations are capped at two weeks.
rtT~S7I[&b	Basic	Launch into Computing::Unit 04 - Software Engineering	What milestones and weights does FDD use during an iteration?	According to Chapter 19 of Beginning Software Engineering: Domain Walkthrough (1%), Design (40%), Design Inspection (3%), Code (45%), Code Inspection (10%), Promote to Build (1%).
iB8wl%=nq|	Basic	Launch into Computing::Unit 04 - Software Engineering	Why does FDD weight design so heavily?	Per Chapter 19 of Beginning Software Engineering, heavy design upfront within each short iteration sets diverse teams up for success and reduces downstream defects on large projects.
ek=WoiyuYC	Basic	Launch into Computing::Unit 04 - Software Engineering	What is Disciplined Agile Delivery (DAD)?	DAD is a people-first, learning-oriented hybrid agile framework that blends scrum, XP, UP, kanban, and Lean to deliver risk-aware, goal-driven, scalable solutions; according to Chapter 19 of Beginning Software Engineering, it spans inception through transition.
zf}Ez1&b;)	Basic	Launch into Computing::Unit 04 - Software Engineering	What are key DAD principles?	According to Chapter 19 of Beginning Software Engineering: people-first, learning-oriented, hybrid, agile/iterative, risk-value life cycle, goal-driven prioritization, enterprise awareness, and scalability.
E[k[7YF_JW	Basic	Launch into Computing::Unit 04 - Software Engineering	What primary roles does DAD define?	Per Chapter 19 of Beginning Software Engineering: Stakeholder, Product Owner, Architecture Owner, Team Lead (agile coach), and cross-functional Team Members.
Mp/%8Z68wL	Basic	Launch into Computing::Unit 04 - Software Engineering	What secondary roles does DAD include?	According to Chapter 19 of Beginning Software Engineering: Domain Expert, Technical Expert, Integrator, Independent Tester, and Specialist (e.g., UX).
zEE<)[7bN`	Basic	Launch into Computing::Unit 04 - Software Engineering	What phases does DAD use?	Per Chapter 19 of Beginning Software Engineering: Inception (vision, risks, enterprise alignment), Construction (iterative delivery with early architectural validation and continuous learning), and Transition (deploy using sound rollout techniques).
u/Bm/!Ax$[	Basic	Launch into Computing::Unit 04 - Software Engineering	What is Dynamic Systems Development Method (DSDM)?	DSDM (now under the Agile Business Consortium) is a heavier agile framework that adds business discipline and lifecycle structure atop RAD practices; according to Chapter 19 of Beginning Software Engineering, it often sits “above” methods like scrum.
z)m:-*%n)~	Basic	Launch into Computing::Unit 04 - Software Engineering	What phases does DSDM define?	According to Chapter 19 of Beginning Software Engineering: Pre-project; Project Life Cycle (Study, Functional Model, Design & Build, Implementation); and Post-project (maintenance).
"t+8V*#k=.H"	Basic	Launch into Computing::Unit 04 - Software Engineering	How are requirements prioritized in DSDM?	Per Chapter 19 of Beginning Software Engineering, DSDM uses facilitated workshops and the MoSCoW method (Must, Should, Could, Won’t) during the Study stage.
gm:2yh-Mlx	Basic	Launch into Computing::Unit 04 - Software Engineering	What are DSDM’s principles?	According to Chapter 19 of Beginning Software Engineering: active user involvement, team empowerment, frequent delivery, meeting business needs, iterative/incremental development, reversible changes, constant testing, collaboration, progressive refinement of requirements, and the 80/20 rule focus.
mc}10uj=6`	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the “80/20 rule” in DSDM?	It assumes roughly 80% of value comes from 20% of features, so teams deliver that high-value portion first; according to Chapter 19 of Beginning Software Engineering, the idea guides effort toward maximum impact.
N6Cf0aWBua	Basic	Launch into Computing::Unit 04 - Software Engineering	What core roles does DSDM specify?	Per Chapter 19 of Beginning Software Engineering: Executive Sponsor, Visionary, Ambassador User, Technical Coordinator, Developer, Tester, and Project Manager, with optional roles like Business Analyst and DSDM Coach.
LVsNR,2-z7	Basic	Launch into Computing::Unit 04 - Software Engineering	What is kanban in software development?	Kanban adapts just-in-time “pull” production control to software by visualizing work, limiting work-in-progress, and pulling the next highest-priority item when capacity frees.
b)AdKobGd+	Basic	Launch into Computing::Unit 04 - Software Engineering	What are kanban’s guiding principles for adoption?	According to Chapter 19 of Beginning Software Engineering: start with current practices, seek incremental change, respect the current process (and roles), and encourage leadership at every level.
g8v6J{7<Zv	Basic	Launch into Computing::Unit 04 - Software Engineering	What are kanban’s core practices?	Per Chapter 19 of Beginning Software Engineering: visualize workflow (information radiator), limit WIP to reduce multitasking costs, and enhance flow by pulling the next item as soon as capacity frees.
gSIiq33ZFQ	Basic	Launch into Computing::Unit 04 - Software Engineering	How does kanban differ from scrum in cadence?	Kanban flows continuously one item at a time without fixed sprints, while scrum uses timeboxed sprints; according to Chapter 19 of Beginning Software Engineering, kanban can deliver more frequently and respond rapidly to changing priorities.
g(d7!cLtLN	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a kanban board?	A kanban board is a visible board (physical or digital) with columns such as Backlog, Ready, Coding, Testing, Approval, and Done that shows each task’s status at a glance; limiting WIP in “in-progress” columns is central to its use.
p4.@@GAFl>	Basic	Launch into Computing::Unit 04 - Software Engineering	How can WIP limits be indicated on a kanban board?	According to Chapter 19 of Beginning Software Engineering, teams mark certain columns as WIP and set explicit card limits; too many cards in WIP signals overcommitment and flow problems.
COWfR6^3ih	Basic	Launch into Computing::Unit 04 - Software Engineering	How can large projects manage kanban boards?	Per Chapter 19 of Beginning Software Engineering, large efforts typically use digital boards to hold many tasks, auto-sort by priority, and link to task details.
x5H)qgjZ2!	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the distinction between ethics and morality?	Ethics refers to societal standards of right and wrong, while morality refers to personal principles of right and wrong. For example, ethics may address whether it is acceptable to park in a handicapped spot, while morality may address personal choices like adultery.
n,{tgWXi5N	Basic	Launch into Computing::Unit 04 - Software Engineering	Why should software developers study ethics?	According to Chapter 20 of Beginning Software Engineering, software developers should study ethics to recognise ethical questions when they arise and have a framework for handling them, similar to how firefighters or doctors train to respond quickly in critical situations.
fE3;[]kR$@	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the IEEE-CS/ACM Code of Ethics?	According to Chapter 20 of Beginning Software Engineering, the IEEE-CS/ACM Code of Ethics requires software engineers to act in the public interest, serve clients and employers ethically, ensure product quality, maintain professional judgment, promote ethical management, advance the profession, support colleagues, and pursue lifelong learning in ethical practice.
Lbug)!h+,`	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the core values in the Australian Computer Society (ACS) Code of Professional Conduct?	According to Chapter 20 of Beginning Software Engineering, the ACS Code of Professional Conduct emphasises the primacy of the public interest, enhancement of quality of life, honesty, competence, professional development, and professionalism, with public interest taking precedence in conflicts.
BV}<+C2yg0	Basic	Launch into Computing::Unit 04 - Software Engineering	What are the Ten Commandments of Computer Ethics?	According to Chapter 20 of Beginning Software Engineering, the Ten Commandments of Computer Ethics include prohibitions against harming others, interfering with work, snooping, stealing, lying, pirating software, and misusing resources, as well as commands to respect intellectual output, consider social consequences, and treat others with respect.
pP8ie{z|gB	Basic	Launch into Computing::Unit 04 - Software Engineering	What are common principles in business ethics?	Common principles in business ethics include honesty, fairness, integrity, compassion, respect, responsibility, loyalty, lawfulness, leadership, trustworthiness, accountability, transparency, and environmental consciousness.
N~N~N%iD2k	Basic	Launch into Computing::Unit 04 - Software Engineering	What lesson is highlighted in the Ernst & Young case study?	According to Chapter 20 of Beginning Software Engineering, the Ernst & Young case, where employees cheated on ethics exams and the firm was fined $100 million, highlights the irony and importance of genuinely following ethical rules rather than superficially meeting requirements.
j32y/Si8=;	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the National Automobile Dealers Association (NADA) Code of Ethics?	According to Chapter 20 of Beginning Software Engineering, the NADA Code of Ethics requires dealers to operate with high standards, treat customers fairly, represent products honestly, provide transparency in charges, honour warranties, resolve issues promptly, and put promises in writing—principles that also apply well to software engineering.
L?$R!O;!^Z	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the “hacker ethic” described by Steven Levy?	According to Chapter 20 of Beginning Software Engineering, the hacker ethic includes ideals such as unrestricted access to computers, freedom of information, mistrust of authority, judging hackers by skill rather than credentials, the belief that computers can create art and beauty, and the idea that computers can change lives for the better.
O?CX!ERoqw	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a white hat hacker?	A white hat hacker is an ethical hacker who breaks into systems with permission, identifies security issues, and reports them responsibly without causing harm.
xVaq`7wX=z	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a black hat hacker?	A black hat hacker is a malicious hacker who breaks into systems for personal gain, disruption, or harm.
"c[I`b#6(L6"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a grey hat hacker?	A grey hat hacker is someone who hacks without permission like a black hat but may report vulnerabilities or offer to fix them like a white hat, blurring ethical lines.
ilHPF,/mP!	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a script kiddie?	A script kiddie is an unskilled individual who uses prewritten tools or scripts to break into systems without understanding the underlying technology.
yYNIr;42u`	Basic	Launch into Computing::Unit 04 - Software Engineering	What is a hacktivist?	A hacktivist is a hacker who uses technical skills as a form of civil disobedience to promote political, ideological, or social causes.
L=M]PR[p:%	Basic	Launch into Computing::Unit 04 - Software Engineering	What is responsibility in the context of software engineering?	According to Chapter 20 of Beginning Software Engineering, responsibility in software engineering means considering how software could be misused, whether bugs could cause harm, and what the worst possible outcomes might be, since engineers may bear responsibility for unintended consequences.
"Es{l}a3g$#"	Basic	Launch into Computing::Unit 04 - Software Engineering	What lessons were learned from the Therac-25, Ariane 5, and other software disasters?	According to Chapter 20 of Beginning Software Engineering, software failures such as the Therac-25 radiation overdoses and the Ariane 5 rocket explosion show that bugs or misunderstandings can cause catastrophic harm, and developers bear responsibility for testing and anticipating risks in life-critical systems.
rYG_XXLS[^	Basic	Launch into Computing::Unit 04 - Software Engineering	What kinds of gray areas exist in software ethics?	According to Chapter 20 of Beginning Software Engineering, gray areas in software ethics include features like infinite scroll, addictive in-app purchases, online gambling, military software, and surveillance systems, where benefits such as entertainment or security may conflict with risks such as addiction, harm, or authoritarian abuse.
P4}vSNKc}U	Basic	Launch into Computing::Unit 04 - Software Engineering	What ethical issues are raised by Edward Snowden’s case?	According to Chapter 20 of Beginning Software Engineering, Edward Snowden’s disclosure of NSA surveillance programs illustrates a moral dilemma, where some view him as a hero for exposing government overreach while others consider him a traitor for endangering security, showing the deep societal division over such ethical questions.
"k{v{#ZQ1!x"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is algorithmic bias?	Algorithmic bias occurs when models produce unfair outcomes for groups due to biased data, unsuitable features, or modeling choices that encode historical inequities.
"A~(#Ls%0dh"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is false confidence in AI systems?	According to Chapter 20 of Beginning Software Engineering, false confidence arises when users assume software is more correct or unbiased than it really is, such as judges over-relying on AI risk assessment scores without recognising underlying data bias.
dryE@g0NoY	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is oversight important in software systems?	According to Chapter 20 of Beginning Software Engineering, oversight is critical to catch errors, analyse outputs for bias, validate results, and ensure that programs assist humans rather than replace human judgment entirely.
"KsE%ebAA#N"	Basic	Launch into Computing::Unit 04 - Software Engineering	What are some ethical issues in getting paid for software projects?	According to Chapter 20 of Beginning Software Engineering, ethical issues include clients who underpay, delay, or refuse payment, and programmers who retaliate with logic bombs or obfuscation. Both violate ethical principles, so fair contracts and incremental payments are recommended safeguards.
L)rUaws&tS	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the tunnel problem in AI ethics?	According to Chapter 20 of Beginning Software Engineering, the tunnel problem is a thought experiment where a self-driving car must choose between harming passengers or pedestrians in unavoidable crash scenarios, raising questions of whose lives should be prioritised and who decides the car’s programming.
c1-xZ~k$Q{	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the trolley problem in ethics?	The trolley problem is a thought experiment where one must choose between allowing multiple people to die or taking an action that sacrifices one person to save many, illustrating the tension between utilitarianism and moral responsibility.
h`$&GVD@yk	Basic	Launch into Computing::Unit 04 - Software Engineering	How does the trolley problem relate to AI?	According to Chapter 20 of Beginning Software Engineering, the trolley problem highlights challenges for AI decision-making, where programming an AI to “save the most lives” may raise questions about acceptable means, responsibility, and the nature of ethical codes in intelligent systems.
N%RE&d^L{f	Basic	Launch into Computing::Unit 04 - Software Engineering	What key questions should software engineers ask when evaluating project ethics?	According to Chapter 20 of Beginning Software Engineering, key ethical questions include: Will this project help or hurt the public? Will it benefit or harm users? Is it transferring value fairly? Can safeguards prevent abuse? And is it being described honestly so users can make informed decisions?
DbC)T=aghX	Basic	Launch into Computing::Unit 04 - Software Engineering	What makes predicting the future of technology difficult?	Predicting the future of technology is difficult because software and hardware evolve rapidly, making it hard to know what will happen even in the near term, let alone years ahead.
ldJ-0;3AqP	Basic	Launch into Computing::Unit 04 - Software Engineering	What role does security play in future software engineering?	According to Chapter 21 of Beginning Software Engineering, security will remain a growth industry due to increasing threats like malware, phishing, and state-sponsored hacking, with trends such as shift-left security, DevSecOps, vulnerability disclosure programs, and improved cryptography shaping its future.
bd3cdP2Tw;	Basic	Launch into Computing::Unit 04 - Software Engineering	What is blockchain and how might it be used beyond cryptocurrency?	According to Chapter 21 of Beginning Software Engineering, blockchain is a distributed ledger system that verifies transactions without a central authority. Beyond cryptocurrency, it could support areas such as government records, business contracts, patents, and copyrights, though energy-intensive proof-of-work remains a limitation.
m~28OgsxTj	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is UX and UI design important for the future of software?	According to Chapter 21 of Beginning Software Engineering, UX and UI design are vital because poorly designed interfaces continue to frustrate users, and future trends like digital experience, progressive web apps, and responsive design demand consistent, user-friendly interactions across devices and platforms.
b[<=A>-gR|	Basic	Launch into Computing::Unit 04 - Software Engineering	What is digital experience (DX)?	Digital experience (DX) refers to the entire set of interactions people have with a company across all digital touchpoints, including applications, websites, services, social media, email, and messaging, all of which should be coordinated to present a consistent brand image.
ztctbIERZV	Basic	Launch into Computing::Unit 04 - Software Engineering	What is responsive design?	Responsive design is a design approach that adapts applications and websites to the user’s device and screen size, whether a large desktop monitor or a small mobile device, ensuring usability and consistency across platforms.
w}]D`J.u8)	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is code packaging important in large software projects?	According to Chapter 21 of Beginning Software Engineering, code packaging is essential because the human brain cannot handle millions of lines of code at once. Packaging into modules, services, or microservices allows developers to focus on smaller, self-contained parts, making large systems manageable and reliable.
G{Z_gx:.&z	Basic	Launch into Computing::Unit 04 - Software Engineering	What are some modern approaches to code packaging?	According to Chapter 21 of Beginning Software Engineering, modern approaches to code packaging include services such as software as a service (SaaS), infrastructure as a service (IaaS), function as a service (FaaS), database as a service (DBaaS), microservices, containerization, and security as a service (SECaaS).
i$h,$MId=[	Basic	Launch into Computing::Unit 04 - Software Engineering	What is edge computing and why is it important?	According to Chapter 21 of Beginning Software Engineering, edge computing moves computation and storage closer to data sources, such as IoT devices, reducing latency, network usage, and centralized storage needs. This is crucial given the massive data generated by billions of IoT devices.
FxF[r{wAk=	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the Internet of Behaviors (IoB)?	According to Chapter 21 of Beginning Software Engineering, the Internet of Behaviors (IoB) is the study of how and why people use technology to make purchasing decisions, with companies analysing this information to influence consumer behaviour.
y)-Q=u;8))	Basic	Launch into Computing::Unit 04 - Software Engineering	What role does Agile play in future software development?	According to Chapter 21 of Beginning Software Engineering, Agile methodologies remain central to software development and are evolving with trends like continuous integration, continuous delivery, and continuous deployment (CI/CD).
Eh0:OE>GIy	Basic	Launch into Computing::Unit 04 - Software Engineering	What is continuous integration and continuous delivery/deployment (CI/CD)?	Continuous integration and continuous delivery/deployment (CI/CD) is the practice of frequently merging code changes, automatically testing them, and delivering updates rapidly to users, though it requires careful testing to avoid bugs and instability.
b4,u,u.uLE	Basic	Launch into Computing::Unit 04 - Software Engineering	What is low-code/no-code (LCNC) development?	According to Chapter 21 of Beginning Software Engineering, low-code/no-code (LCNC) platforms allow non-programmers to build useful applications with minimal coding, often through drag-and-drop interfaces. While they may not scale well for complex projects, they are a growing trend.
rFu=<?jh8$	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is learning new programming languages valuable?	According to Chapter 21 of Beginning Software Engineering, learning new programming languages expands a developer’s techniques, enhances problem-solving, improves employability, and keeps the mind flexible. Languages like Swift, Rust, Kotlin, TypeScript, and Python are currently popular and influential.
w76%La43E_	Basic	Launch into Computing::Unit 04 - Software Engineering	What is Rust and why is it significant?	Rust is a systems programming language that emphasises type safety, memory safety, performance, and concurrency. It is gaining traction with major companies like Amazon, Google, Microsoft, and Facebook.
vX]>%04>?A	Basic	Launch into Computing::Unit 04 - Software Engineering	What is Kotlin and where is it commonly used?	Kotlin is a modern, concise language that interoperates with Java and compiles to JVM, JavaScript, or native code. It is Google’s preferred language for Android development.
c8Vg:nR0/1	Basic	Launch into Computing::Unit 04 - Software Engineering	Why is Python considered important today?	Python is important because it is beginner-friendly, widely taught in universities, used heavily in artificial intelligence and research, and has strong industry demand, making it both accessible and powerful for diverse applications.
c&uCPp!vnp	Basic	Launch into Computing::Unit 04 - Software Engineering	What is machine learning?	Machine learning is a branch of artificial intelligence where algorithms learn patterns from training data and apply that knowledge to make predictions or decisions about new data.
pEWDq[1<Wd	Basic	Launch into Computing::Unit 04 - Software Engineering	What are some applications of machine learning?	Applications of machine learning include facial recognition, voice recognition, data mining, translation, fraud detection, search engines, astronomy, economics, medical diagnosis, and intelligent process automation.
"jk+w1]Q#z?"	Basic	Launch into Computing::Unit 04 - Software Engineering	What is intelligent process automation (IPA)?	Intelligent process automation (IPA) combines robotic automation with AI techniques such as natural language processing and computer vision to streamline workflows and reduce costs, as in automated warehouse operations.
H,YP=cgYXi	Basic	Launch into Computing::Unit 04 - Software Engineering	What is cloud automation?	Cloud automation uses intelligent tools to manage and optimise cloud resources, such as automatically provisioning databases, tuning performance, and handling queries, reducing manual intervention.
B!.?(Fy>5/	Basic	Launch into Computing::Unit 04 - Software Engineering	What is quantum computing?	Quantum computing is a computational paradigm that uses quantum mechanics to solve certain problems, like large-scale factorisation, far faster than classical computers. It shows promise for fields such as cryptography, though practical applications are still developing.
LpGeMog^@<	Basic	Launch into Computing::Unit 04 - Software Engineering	What is quantum supremacy?	Quantum supremacy is the idea that a quantum computer can solve problems that are impractical for classical computers to compute within a reasonable time.
IW3x0!9kU-	Basic	Launch into Computing::Unit 04 - Software Engineering	What are current uses of virtual reality (VR)?	According to Chapter 21 of Beginning Software Engineering, current uses of VR include gaming, education and training, and product visualisation, where immersive simulations provide experiences that would otherwise be expensive, dangerous, or impossible.
I*)m`&&fD:	Basic	Launch into Computing::Unit 04 - Software Engineering	What is augmented reality (AR)?	Augmented reality (AR) overlays computer-generated images or data onto the real world, enhancing perception. Examples include heads-up displays, engineering diagrams, and composite visuals through AR glasses.
iEUBcYUk@y	Basic	Launch into Computing::Unit 04 - Software Engineering	Why are VR and AR considered technologies with potential?	According to Chapter 21 of Beginning Software Engineering, VR and AR are considered technologies with potential because they are already used in industries such as medicine, architecture, and automotive design, but have yet to reach full adoption in education and everyday applications.
O^j?n:!YD>	Basic	Launch into Computing::Unit 04 - Software Engineering	What is the employment outlook for software engineers?	According to Chapter 21 of Beginning Software Engineering, employment for software developers, quality assurance analysts, and testers is projected to grow by 22 percent from 2020 to 2030, much faster than average for all occupations, ensuring a stable future for the field.
